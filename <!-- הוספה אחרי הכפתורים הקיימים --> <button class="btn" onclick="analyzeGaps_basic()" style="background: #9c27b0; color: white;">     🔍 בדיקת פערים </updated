    

<!DOCTYPE html>
<html dir="rtl" lang="he">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>מחשבון מילואים מתקדם - גרסה 2.0</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(45deg, #2c3e50, #3498db);
            color: white;
            padding: 30px;
            text-align: center;
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .header p {
            font-size: 1.2em;
            opacity: 0.9;
        }

        .upload-section {
            padding: 40px;
            background: #f8f9fa;
            border-bottom: 1px solid #e9ecef;
        }

        .upload-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .upload-card {
            background: white;
            border: 2px dashed #ddd;
            border-radius: 10px;
            padding: 20px;
            text-align: center;
            transition: all 0.3s ease;
            cursor: pointer;
        }

        .upload-card:hover {
            border-color: #3498db;
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(52, 152, 219, 0.2);
        }

        .upload-card.uploaded {
            border-color: #27ae60;
            background: #d5f4e6;
        }

        .upload-card h3 {
            color: #2c3e50;
            margin-bottom: 10px;
        }

        .upload-card p {
            color: #7f8c8d;
            font-size: 0.9em;
            margin-bottom: 15px;
        }

        .file-input {
            display: none;
        }

        .upload-btn {
            background: #3498db;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 0.9em;
            transition: background 0.3s ease;
        }

        .upload-btn:hover {
            background: #2980b9;
        }

        .upload-btn.success {
            background: #27ae60;
        }

        .controls {
            display: flex;
            gap: 15px;
            justify-content: center;
            flex-wrap: wrap;
        }

        .btn {
            background: #e74c3c;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 25px;
            cursor: pointer;
            font-size: 1em;
            font-weight: bold;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(231, 76, 60, 0.3);
        }

        .btn:hover {
            background: #c0392b;
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(231, 76, 60, 0.4);
        }

        .btn:disabled {
            background: #bdc3c7;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .filters {
            padding: 30px 40px;
            background: white;
            border-bottom: 1px solid #e9ecef;
        }

        .filter-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
        }

        .filter-group {
            display: flex;
            flex-direction: column;
        }

        .filter-group label {
            font-weight: bold;
            color: #2c3e50;
            margin-bottom: 5px;
        }

        .filter-group input, .filter-group select {
            padding: 10px;
            border: 2px solid #ddd;
            border-radius: 5px;
            font-size: 1em;
            transition: border-color 0.3s ease;
        }

        .filter-group input:focus, .filter-group select:focus {
            outline: none;
            border-color: #3498db;
        }

        .results-section {
            padding: 40px;
        }

        .summary-stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .stat-card {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
        }

        .stat-number {
            font-size: 2em;
            font-weight: bold;
            margin-bottom: 5px;
        }

        .stat-label {
            font-size: 0.9em;
            opacity: 0.9;
        }

        .results-table {
            background: white;
            border-radius: 10px;
            overflow: hidden;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
        }

        table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.9em;
        }

        th {
            background: #34495e;
            color: white;
            padding: 15px 10px;
            text-align: center;
            font-weight: bold;
            white-space: nowrap;
        }

        td {
            padding: 12px 10px;
            text-align: center;
            border-bottom: 1px solid #e9ecef;
            white-space: nowrap;
        }

        tr:nth-child(even) {
            background: #f8f9fa;
        }

        tr:hover {
            background: #e3f2fd;
        }

      .new-miluim {
            background: #e1f5fe !important;
            border-right: 4px solid #03a9f4;
        }
        .emergency-cluster {
            background: #fff3e0 !important;
            border-right: 4px solid #ff9800;
        }

        .alternative-calc {
            color: #e74c3c;
            font-weight: bold;
        }

        .locked-value {
            background: #ffebee !important;
            color: #c62828;
            font-weight: bold;
        }

        .details-btn {
            background: #3498db;
            color: white;
            border: none;
            padding: 5px 10px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 0.8em;
        }

        .details-btn:hover {
            background: #2980b9;
        }

        .loading {
            text-align: center;
            padding: 40px;
            font-size: 1.2em;
            color: #7f8c8d;
        }

        .error {
            background: #ffe6e6;
            color: #c62828;
            padding: 15px;
            border-radius: 5px;
            margin: 10px 0;
            border-right: 4px solid #e74c3c;
        }

        .success {
            background: #e8f5e8;
            color: #2e7d32;
            padding: 15px;
            border-radius: 5px;
            margin: 10px 0;
            border-right: 4px solid #4caf50;
        }

        /* Modal styles */
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.5);
        }

        .modal-content {
            background: white;
            margin: 5% auto;
            padding: 30px;
            border-radius: 10px;
            width: 90%;
            max-width: 800px;
            max-height: 80vh;
            overflow-y: auto;
            position: relative;
 }
            .amount-difference {
                font-weight: bold;
            }
            
            .positive-diff {
                color: #2e7d32; 
            }
            
            .negative-diff {
                color: #c62828; 
            }        }

        .close {
            color: #aaa;
            float: left;
            font-size: 28px;
            font-weight: bold;
            position: absolute;
            top: 15px;
            left: 20px;
            cursor: pointer;
        }

        .close:hover {
            color: #000;
        }

        .calculation-step {
            background: #f8f9fa;
            border-radius: 8px;
            padding: 15px;
            margin: 15px 0;
            border-right: 4px solid #3498db;
        }

        .step-title {
            font-weight: bold;
            color: #2c3e50;
            margin-bottom: 10px;
            font-size: 1.1em;
        }

        .step-detail {
            color: #555;
            line-height: 1.6;
        }

        .export-section {
            text-align: center;
            padding: 30px;
            background: #f8f9fa;
            border-top: 1px solid #e9ecef;
        }

        .export-btn {
            background: #27ae60;
            color: white;
            border: none;
            padding: 15px 30px;
            border-radius: 25px;
            cursor: pointer;
            font-size: 1.1em;
            font-weight: bold;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(39, 174, 96, 0.3);
        }

        .export-btn:hover {
            background: #229954;
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(39, 174, 96, 0.4);
        }

        .sheet-status {
            display: flex;
            justify-content: space-around;
            flex-wrap: wrap;
            gap: 10px;
        }

        .sheet-status span {
            padding: 5px 10px;
            border-radius: 15px;
            background: #f0f0f0;
            font-size: 0.9em;
            white-space: nowrap;
        }

        .sheet-loaded {
            background: #d5f4e6 !important;
            color: #2e7d32;
        }
            .container {
                margin: 10px;
                border-radius: 10px;
            }
            
            .header {
                padding: 20px;
            }
            
            .header h1 {
                font-size: 1.8em;
            }
            
            .upload-section, .filters, .results-section {
                padding: 20px;
            }
            
            .controls {
                flex-direction: column;
                align-items: center;
            }
            
            table {
                font-size: 0.8em;
            }
            
            th, td {
                padding: 8px 5px;
            }
        }
/* 🆕 עיצוב לכפתור הייצוא */
.analysis-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 20px;
}

.analysis-buttons {
    display: flex;
    gap: 10px;
}
/* רקע שקוף - חיוני לחלון! */
.overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0,0,0,0.5);
    z-index: 1000;
    display: none;
}

.close-btn {
    background: none;
    border: none;
    color: white;
    font-size: 24px;
    cursor: pointer;
    padding: 0;
    width: 30px;
    height: 30px;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
}

.close-btn:hover {
    background: rgba(255,255,255,0.2);
}

.analysis-header h2 {
    margin: 0;
    font-size: 1.5em;
}
/* עיצוב חלון אנליזה */
.analysis-window {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    width: 90%;
    max-width: 1000px;
    height: 80%;
    background: white;
    border-radius: 10px;
    box-shadow: 0 10px 30px rgba(0,0,0,0.3);
    z-index: 1001;
    display: none;
    overflow: hidden;
}

.analysis-header {
    background: linear-gradient(45deg, #9c27b0, #673ab7);
    color: white;
    padding: 20px;
    display: flex;
    justify-content: space-between;
    align-items: center;
}

.analysis-content {
    padding: 20px;
    height: calc(100% - 80px);
    overflow-y: auto;
}

.analysis-summary {
    background: #f8f9fa;
    padding: 15px;
    border-radius: 8px;
    margin-bottom: 20px;
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
    gap: 15px;
}

.summary-stat {
    text-align: center;
    padding: 10px;
    background: white;
    border-radius: 5px;
}

.category-box {
    border: 2px solid #e0e0e0;
    border-radius: 8px;
    margin-bottom: 15px;
    overflow: hidden;
}

.category-header {
    padding: 15px;
    font-weight: bold;
    cursor: pointer;
    display: flex;
    justify-content: space-between;
    align-items: center;
}

.category-ok { background: #e8f5e8; border-color: #4caf50; }
.category-fix { background: #ffebee; border-color: #f44336; }
.category-check { background: #fff3e0; border-color: #ff9800; }

.category-content {
    padding: 15px;
    display: none;
    background: #fafafa;
    max-height: 300px;
    overflow-y: auto;
}
    </style>
</head>
<body>
    <div class="container">
        <!-- Header -->
        <div class="header">
            <h1>🎖️ מחשבון מילואים מתקדם</h1>
            <p>גרסה 2.0 - חישוב מדויק של תגמולי מילואים לפי התקנות הישראליות</p>
        </div>
        <!-- Upload Section -->
        <div class="upload-section">
            <div class="upload-grid">
                <div class="upload-card" onclick="document.getElementById('excelFile').click()" style="grid-column: 1 / -1;">
                    <h3>📊 קובץ אקסל עם 3 גליונות</h3>
                    <p>גליון 1: מילואים (90291) | גליון 2: שכר (94010) | גליון 3: נוכחות (1857)</p>
                    <button class="upload-btn" id="excelBtn">בחר קובץ אקסל</button>
                    <input type="file" id="excelFile" class="file-input" accept=".xlsx,.xls">
                    <div id="sheetsStatus" style="margin-top: 15px; display: none;">
                        <div class="sheet-status">
                            <span id="sheet1Status">📊 גליון מילואים: ❌</span>
                            <span id="sheet2Status">💰 גליון שכר: ❌</span>
                            <span id="sheet3Status">📅 גליון נוכחות: ❌</span>
                        </div>
                    </div>
                </div>
            </div>

            <div class="controls">
                <button class="btn" id="calculateBtn" disabled>🧮 חשב מילואים</button>
                <button class="btn" id="clearBtn">🗑️ נקה הכל</button>
<!-- הוספה אחרי הכפתורים הקיימים -->
<button class="btn" onclick="analyzeGaps_basic()" style="background: #9c27b0; color: white;">
    🔍 בדיקת פערים
</button>
                <button class="btn" id="singleEmployeeBtn" style="background: linear-gradient(45deg, #8e44ad, #9b59b6); display: none;" onclick="showEmployeeSelector()">
    👤 חישוב לעובד בודד
</button>
<!-- הקלדת מספר עובד -->
<div id="employeeSelectorDiv" style="display: none; margin-top: 15px; padding: 15px; background: #f8f9fa; border-radius: 8px;">
    <label for="employeeInput" style="margin-left: 10px; font-weight: bold;">הקלד מספר עובד:</label>
    <input type="text" 
           id="employeeInput" 
           placeholder="לדוגמה: 12345" 
           style="padding: 8px; margin-left: 10px; margin-right: 10px; border: 1px solid #ddd; border-radius: 4px; width: 150px;">
  <button class="btn" id="calculateSingleBtn" style="background: #27ae60;" onclick="const emp = document.getElementById('employeeInput').value.trim(); if(emp) calculateMiluim({employeeIds: [emp], addEmployeeHeader: true, batchSize: 0}); else alert('éù ìäæéï îñôø òåáã');" disabled>
  🎯 חשב
    <span id="employeeValidation" style="margin-right: 10px; color: #e74c3c;"></span>
</div>
            </div>
        </div>

        <!-- Filters -->
        <div class="filters">
            <h3 style="margin-bottom: 20px; color: #2c3e50;">🔍 מסנני תצוגה</h3>
            <div class="filter-grid">
                <div class="filter-group">
                    <label for="employeeFilter">מספר עובד:</label>
                    <input type="text" id="employeeFilter" placeholder="הזן מספר זהות (או חלק ממנו)">
                </div>
                <div class="filter-group">
                    <label for="yearFilter">שנה:</label>
                    <select id="yearFilter">
                        <option value="">כל השנים</option>
                        <option value="2023">2023</option>
                        <option value="2024">2024</option>
                        <option value="2025">2025</option>
                    </select>
                </div>
                <div class="filter-group">
                    <label for="miluimTypeFilter">סוג מילואים:</label>
                    <select id="miluimTypeFilter">
                        <option value="">כל הסוגים</option>
                        <option value="regular">רגילים (לפני 07.10.2023)</option>
                        <option value="emergency">חירום (07.10.2023 - 30.04.2025)</option>
                        <option value="new">חדשים (מ-01.05.2025)</option>
                        <option value="locked">נעולים (ערך מוגבל)</option>
                        <option value="gap">עם פער (הפרש בתשלום)</option>
                         <option value="crossMonth">מילואים גולשים</option>
                    </select>
                </div>
                <div class="filter-group">
                    <button class="btn" onclick="clearFilters()" style="margin-top: 25px; background: #95a5a6;">🗑️ נקה סינון</button>
                </div>
            </div>
        </div>

        <!-- Results Section -->
        <div class="results-section">
            <div id="summaryStats" class="summary-stats" style="display: none;">
                <div class="stat-card">
                    <div class="stat-number" id="totalEmployees">0</div>
                    <div class="stat-label">עובדים</div>
                </div>
                <div class="stat-card">
                    <div class="stat-number" id="totalPeriods">0</div>
                    <div class="stat-label">תקופות מילואים</div>
                </div>
                <div class="stat-card">
                    <div class="stat-number" id="totalDays">0</div>
                    <div class="stat-label">ימי מילואים</div>
                </div>
                <div class="stat-card">
                    <div class="stat-number" id="totalPayment">₪0</div>
                    <div class="stat-label">סה"כ תשלום</div>
                </div>
            </div>

            <div id="resultsContainer">
                <div class="loading" id="loadingMessage" style="display: none;">
                    🔄 מעבד נתונים...
                </div>
            </div>
        </div>

        <!-- Export Section -->
        <div class="export-section" id="exportSection" style="display: none;">
            <button class="export-btn" id="exportBtn">📥 ייצא לאקסל</button>
        </div>
    </div>

    <!-- Modal for detailed calculations -->
    <div id="detailsModal" class="modal">
        <div class="modal-content">
            <span class="close">&times;</span>
            <div id="detailsContent"></div>
        </div>
    </div>

    <script>
        // Global variables
        let miluimData = [];
        let salaryData = [];
        let attendanceData = [];
        let calculationResults = [];
        let filteredResults = [];
        // משתנים לשמירת הנתונים המקוריים
        let originalMiluimData = [];
        let originalSalaryData = [];
        let originalAttendanceData = []; 
        let showCrossMonthOnly =[] ; 
        let currentDisplayData = [];
        let currentDisplayOptions = {};
       

        // Constants
        const EMERGENCY_START = new Date('2023-10-07');
        //מערכת CACHE
class MiluimCalculatorCache {
    constructor() {
        this.cache = new Map();
        this.sortedMiluim = null;
        
        console.log('✓✓✓ מערכת CACHE הופעלה');
    }

    createKey(employeeId, serviceStartDate) {
        return `${employeeId}_${serviceStartDate.toISOString().split('T')[0]}`;
    }

    prepareData() {
       // המרה לפורמט אחיד עם תאריכים מעובדים
        const processedMiluim = miluimData.map(m => ({
            employeeId: m.employeeId,
            startDate: parseExcelDate(m.startDate),
            endDate: parseExcelDate(m.endDate),
            miluimDays: m.miluimDays
        })).filter(m => m.startDate && m.endDate);

        // מיון כרונולוגי - הכי חשוב!
        this.sortedMiluim = processedMiluim.sort((a, b) => a.startDate - b.startDate);
        
        console.log(`? äåëï CACHE òí ${this.sortedMiluim.length} îéìåàéí`);
    }

    calculateWithCache(employeeId, serviceStartDate) {
        const key = this.createKey(employeeId, serviceStartDate);
        
              // בדיקה במטמון
        if (this.cache.has(key)) {
            console.log(`? CACHE HIT: ${key}`);
            return this.cache.get(key);
        }

        console.log(`🔄 חישוב חדש: ${key}`);
        
       // חישוב רגיל עם הפונקציות הקיימות שלך
        const result = this.performOriginalCalculation(employeeId, serviceStartDate);
        
         // שמירה במטמון
        this.cache.set(key, result);
        
        return result;
    }

  performOriginalCalculation(employeeId, serviceStartDate) {
     // 🔥 כאן נשתמש בפונקציות הקיימות שלך בדיוק כמו שהן
    const basicResult = calculateBasicDailyValue(employeeId, serviceStartDate);
    const recommendedValue = calculateRecommendedValue(employeeId, serviceStartDate, basicResult.dailyValue);
    
    const allEmployeeRecords = miluimData
        .filter(m => m.employeeId == employeeId)
        .map(m => ({
            startDate: m.startDate,
            endDate: m.endDate
        }));
    
    const isNewMiluim = IsNewMiluim(employeeId, serviceStartDate, allEmployeeRecords);
    
    // מציאת הנתונים המקוריים מהאקסל
    const continuousResult = calculateContinuousValue(employeeId, serviceStartDate, recommendedValue, isNewMiluim);
    const emergencyValues = calculateEmergencyValues(employeeId, serviceStartDate, continuousResult.value);
    
    const originalMiluim = miluimData.find(m =>
        m.employeeId == employeeId && 
        parseExcelDate(m.startDate).getTime() === serviceStartDate.getTime()
    );

    return {
        employeeId,
        startDate: serviceStartDate,
        basicValue: basicResult.dailyValue,
        recommendedValue,
        continuousValue: continuousResult.value,
        isValueLocked: continuousResult.isLocked,
        emergencyValue: emergencyValues.emergencyValue,
        maxEmergencyValue: emergencyValues.maxEmergencyValue,
        emergencyClusterStart: emergencyValues.emergencyClusterStart,
        calculationType: basicResult.calculationType,
        paidAmount: originalMiluim ? originalMiluim.paidAmount : 0,
        isNewMiluim: isNewMiluim,
        compulsion: originalMiluim ? originalMiluim.compulsion || 0 : 0,
        compulsionContinuous: 0 ,
        emergencyCompulsion4405: originalMiluim ? originalMiluim.emergencyCompulsion4405 || 0 : 0 
    };
}
    getStats() {
        return {
            cacheSize: this.cache.size,
            totalCalculated: this.sortedMiluim ? this.sortedMiluim.length : 0,
            hitRate: this.sortedMiluim ? 
                ((this.sortedMiluim.length - this.cache.size) / this.sortedMiluim.length * 100).toFixed(1) + '%' : '0%'
        };
    }
}

// éöéøú instance âìåáìé
const cacheSystem = new MiluimCalculatorCache();
        const NEW_MILUIM_START = new Date('2025-05-01');
       const PREV_SERVICE_CHECK_DATE = new Date('2025-04-30');
       //const PREV_SERVICE_CHECK_DATE = new Date(2025, 3, 30, 0, 0, 0);
       //const PREV_SERVICE_CHECK_DATE = new Date(excelEpoch.getTime() + (45777 - 1) * 24 * 60 * 60 * 1000);

     function IsNewMiluim(employeeId, serviceStartDate, allEmployeeRecords) {
    // תנאי 1: השירות חייב להיות >= 01.05.2025
    if (serviceStartDate < NEW_MILUIM_START) {
        return false;
    }
    
    const sortedRecords = allEmployeeRecords
        .map(record => ({
            start: parseExcelDate(record.startDate),
            end: parseExcelDate(record.endDate)
        }))
        .filter(record => record.start && record.end)
        .sort((a, b) => a.start - b.start);
    
    const currentIndex = sortedRecords.findIndex(record => 
        record.start.getTime() === serviceStartDate.getTime()
    );
    
    if (currentIndex === -1) return false;
    
    // בדיקה אחורה - האם יש רצף רציף (פער <= 1 יום)
    for (let i = currentIndex - 1; i >= 0; i--) {
        const current = sortedRecords[i + 1];
        const prev = sortedRecords[i];
        
        const gapDays = (current.start - prev.end) / (1000 * 60 * 60 * 24);
        
        if (gapDays > 1) {
            return true; // פער > 1 יום = מילואים חדשים
        }
        
        // אם השירות הקודם התחיל לפני 01.05.2025 - לא מילואים חדשים
        if (prev.start < NEW_MILUIM_START) {
            return false;
        }
    }
    
    return true; // מילואים חדשים
}
        // Minimum bruto by year
        const BRUTO_MINIMUMS = {
            2021: 5987,
            2022: 6131,
            2023: 6455,
            2024: 6668,
            2025: 6895
        };

        // Daily value limits by period
        const DAILY_LIMITS = [
            { start: new Date('2021-01-01'), end: new Date('2021-12-31'), min: 199.57, max: 1502.50 },
            { start: new Date('2022-01-01'), end: new Date('2022-12-31'), min: 204.34, max: 1502.50 },
            { start: new Date('2023-01-01'), end: new Date('2023-10-06'), min: 215.17, max: 1582.17 },
            { start: new Date('2023-10-07'), end: new Date('2023-12-31'), min: 300.61, max: 1582.17 },
            { start: new Date('2024-01-01'), end: new Date('2024-12-31'), min: 310.52, max: 1634.33 },
            { start: new Date('2025-01-01'), end: new Date('2025-12-31'), min: 321.07, max: 1689.83 }
        ];

        // 🔥 תיקון קריטי: פונקציית parseExcelDate מתוקנת
        function parseExcelDate(value) {
            if (!value) return null;
            
            if (value instanceof Date) return value;
            
            // 🔥 תיקון: שינוי מ-value-2 ל-value-1 לפתרון הבעיה של יום אחד לפני
            if (typeof value === 'number') {
                const excelEpoch = new Date(1900, 0, 1);
                const days = value - 1; // ✅ תוקן! השתמש ב-1 במקום 2
                return new Date(excelEpoch.getTime() + days * 24 * 60 * 60 * 1000);
            }
            
            // תמיכה בפורמטי תאריכים שונים
            if (typeof value === 'string') {
                const formats = [
                    /^(\d{4})-(\d{2})-(\d{2})$/,        // YYYY-MM-DD
                    /^(\d{2})\/(\d{2})\/(\d{4})$/,      // DD/MM/YYYY
                    /^(\d{2})-(\d{2})-(\d{4})$/,       // DD-MM-YYYY
                    /^(\d{1,2})\/(\d{1,2})\/(\d{4})$/,  // D/M/YYYY
                    /^(\d{1,2})\.(\d{1,2})\.(\d{4})$/   // D.M.YYYY
                ];
                
                for (let format of formats) {
                    const match = value.match(format);
                    if (match) {
                        if (format.source.startsWith('^(\\d{4})')) {
                            // YYYY-MM-DD format
                            return new Date(parseInt(match[1]), parseInt(match[2]) - 1, parseInt(match[3]));
                        } else {
                            // DD/MM/YYYY or DD-MM-YYYY or D.M.YYYY formats
                            return new Date(parseInt(match[3]), parseInt(match[2]) - 1, parseInt(match[1]));
                        }
                    }
                }
                
                // Try standard Date parsing as fallback
                const parsed = new Date(value);
                return isNaN(parsed.getTime()) ? null : parsed;
            }
            
            return null;
        }

        function formatDate(date) {
    if (!date) return '';
    
    // תיקון timezone - וודא שאנחנו מקבלים את התאריך הנכון
    const adjustedDate = new Date(date.getTime() + (date.getTimezoneOffset() * 60000));
    
    const day = adjustedDate.getDate().toString().padStart(2, '0');
    const month = (adjustedDate.getMonth() + 1).toString().padStart(2, '0');
    const year = adjustedDate.getFullYear();
    
    return `${day}.${month}.${year}`;
}
// פונקציה שמחשבת תחילת חודש של שירות 
function getServiceMonthStart(serviceStartDate) {
    const dateObj = serviceStartDate instanceof Date ? serviceStartDate : new Date(serviceStartDate);
    return new Date(dateObj.getFullYear(), dateObj.getMonth(), 1);
}

        function formatCurrency(amount) {
            return new Intl.NumberFormat('he-IL', {
                style: 'currency',
                currency: 'ILS'
            }).format(amount);
        }

        // 🔥 תיקון קריטי: הוספת פונקציות חסרות מהמפרט
        function ApplyBrutoMinimumFromCSV(bruto, monthDate) {
            const year = monthDate.getFullYear();
            const minimum = BRUTO_MINIMUMS[year] || BRUTO_MINIMUMS[2025];
            return Math.max(bruto, minimum);
        }

        function ApplyFinalLimitsFromCSV(dailyValue, serviceDate) {
            for (let limit of DAILY_LIMITS) {
                if (serviceDate >= limit.start && serviceDate <= limit.end) {
                    return Math.max(limit.min, Math.min(limit.max, dailyValue));
                }
            }
            // Default to latest limits if no match found
            const latestLimit = DAILY_LIMITS[DAILY_LIMITS.length - 1];
            return Math.max(latestLimit.min, Math.min(latestLimit.max, dailyValue));
        }

        // 🔥 תיקון: עדכון GetBrutoForMonth להחיל ברוטו מינימלי
        function GetBrutoForMonth(employeeId, monthDate) {
            const monthStart = new Date(monthDate.getFullYear(), monthDate.getMonth(), 1);
            const monthEnd = new Date(monthDate.getFullYear(), monthDate.getMonth() + 1, 0);
            
            let bestBruto = 0;
            
            for (let salary of salaryData) {
                if (salary.employeeId == employeeId) {
                    const salaryDate = parseExcelDate(salary.monthYear);
                    if (salaryDate && salaryDate >= monthStart && salaryDate <= monthEnd) {
                        bestBruto = Math.max(bestBruto, salary.bruto || 0);
                    }
                }
            }
            
            // 🔥 תיקון: החלת ברוטו מינימלי
            return ApplyBrutoMinimumFromCSV(bestBruto, monthDate);
        }

        function GetWorkDaysForMonth(employeeId, monthDate, serviceStartDate) {
    const monthStart = new Date(monthDate.getFullYear(), monthDate.getMonth(), 1);
    const monthEnd = new Date(monthDate.getFullYear(), monthDate.getMonth() + 1, 0);
    
    let totalDays = 0;
    
    // קביעה איזה עמודה להשתמש בה לפי תאריך השירות
    const isNewMiluim = serviceStartDate >= new Date(2025, 4, 1); // 1 במאי 2025
    
    for (let attendance of attendanceData) {
        if (attendance.employeeId == employeeId) {
            const attendanceDate = parseExcelDate(attendance.monthYear);
            if (attendanceDate >= monthStart && attendanceDate <= monthEnd) {
                // בחר את העמודה הנכונה לפי סוג המילואים
                const workDays = isNewMiluim ? 
                    (attendance.workDaysNew || 0) :  // עמודה D למילואים חדשים
                    (attendance.workDays || 0);      // עמודה C למילואים רגילים
                totalDays += workDays;
            }
        }
    }
    
    return totalDays;
}

        // Core calculation functions - מתוקן לפי המפרט
        function calculateBasicDailyValue(employeeId, serviceStartDate) {
            // 🔥 תיקון: חישוב 3 החודשים שלפני תחילת חודש השירות (לא +1)
            const serviceMonth = new Date(serviceStartDate.getFullYear(), serviceStartDate.getMonth(), 1);
            
            const month1 = new Date(serviceMonth.getFullYear(), serviceMonth.getMonth() - 1, 1);
            const month2 = new Date(serviceMonth.getFullYear(), serviceMonth.getMonth() - 2, 1);
            const month3 = new Date(serviceMonth.getFullYear(), serviceMonth.getMonth() - 3, 1);
            
            // בדיקת ימי עבודה ב-3 חודשים
            const workDays1 = GetWorkDaysForMonth(employeeId, month1, serviceStartDate);
            const workDays2 = GetWorkDaysForMonth(employeeId, month2, serviceStartDate);
            const workDays3 = GetWorkDaysForMonth(employeeId, month3, serviceStartDate);
            const totalWorkDays = workDays1 + workDays2 + workDays3;
            
            let totalBruto = 0;
            let calculation = 'רגיל';
            let monthsUsed = [month1, month2, month3];
            
            if (totalWorkDays >= 60) {
                // חישוב רגיל - 3 חודשים לפני השירות
                totalBruto = GetBrutoForMonth(employeeId, month1) +
                           GetBrutoForMonth(employeeId, month2) +
                           GetBrutoForMonth(employeeId, month3);
            } else {
                // חישוב חלופי - 3 החודשים הטובים מ-6 חודשים לפני
                calculation = 'חלופי';
                const months = [];
                for (let i = 1; i <= 6; i++) {
                    const month = new Date(serviceMonth.getFullYear(), serviceMonth.getMonth() - i, 1);
                    months.push({
                        date: month,
                        bruto: GetBrutoForMonth(employeeId, month)
                    });
                }
                
                // מיון לפי ברוטו יורד ולקיחת 3 הטובים
                months.sort((a, b) => b.bruto - a.bruto);
                monthsUsed = months.slice(0, 3).map(m => m.date);
                totalBruto = months.slice(0, 3).reduce((sum, month) => sum + month.bruto, 0);
            }
            
            const dailyValue = totalBruto / 90;
           let finalValue = ApplyFinalLimitsFromCSV(dailyValue, serviceStartDate);
    

    const employeeMiluim = miluimData
        .filter(m => m.employeeId == employeeId)
        .map(m => ({...m, startDate: parseExcelDate(m.startDate), endDate: parseExcelDate(m.endDate)}))
        .filter(m => m.startDate && m.endDate && m.endDate < serviceStartDate)
        .sort((a, b) => b.endDate - a.endDate);
    
    if (employeeMiluim.length > 0) {
        const mostRecentMiluim = employeeMiluim[0];
        const daysDiff = (serviceStartDate - mostRecentMiluim.endDate) / (1000 * 60 * 60 * 24);
        
        if (daysDiff <= 1) {
            
            const prevBasicResult = calculateBasicDailyValue(employeeId, mostRecentMiluim.startDate);
            const minimumDaily = getMinimumDailyForDate(serviceStartDate);
            finalValue = Math.max(prevBasicResult.dailyValue,minimumDaily);
        }
    }
                          
            return {
                dailyValue: finalValue,
                totalBruto,
                calculationType: calculation,
                workDays: totalWorkDays,
                monthsUsed
            };
        }
function calculateRecommendedValue(employeeId, serviceStartDate, basicValue) {
                 // For new miluim (after 01.05.2025) - don't consider previous service
    if (serviceStartDate >= NEW_MILUIM_START) {
        return basicValue;
    }

    // For regular miluim - check previous service in 60 days before
    
    const checkDate = new Date(serviceStartDate);
    checkDate.setDate(checkDate.getDate() - 60);
    
    
    let previousValue = 0;
    
    for (let miluim of miluimData) {
        if (miluim.employeeId === employeeId) {
            const miluimEnd = parseExcelDate(miluim.endDate);
            const miluimStart = parseExcelDate(miluim.startDate);
            
            if (miluimEnd >= checkDate && miluimEnd < serviceStartDate) {
                // ?? ëàï äùéîåù á-CACHE!
                const prevKey = cacheSystem.createKey(employeeId, miluimStart);
                
                if (cacheSystem.cache.has(prevKey)) {
                    // ? ìå÷ç òøê îåîìõ îäîèîåï
                    const cachedResult = cacheSystem.cache.get(prevKey);
                    previousValue = Math.max(previousValue, cachedResult.recommendedValue);
                } else {
                    // àí àéï áîèîåï, çùá ø÷ áñéñé (fallback)
                    const prevBasic = calculateBasicDailyValue(employeeId, miluimStart);
                    previousValue = Math.max(previousValue, prevBasic.dailyValue);
                }         
                    }
                }
            }
            
            return Math.max(basicValue, previousValue);
        }

            function calculateContinuousValue(employeeId, serviceStartDate, recommendedValue, isNewMiluim = null) {
   // For miluim before emergency period
   if (serviceStartDate < EMERGENCY_START) {
       return {
           value: recommendedValue,
           isLocked: false
       };
   } 

   // àí ìà ÷éáìðå isNewMiluim, çùá àåúå
   if (isNewMiluim === null) {
       const allEmployeeRecords = miluimData
           .filter(m => m.employeeId == employeeId)
           .map(m => ({
               startDate: m.startDate,
               endDate: m.endDate
           }));
       isNewMiluim = IsNewMiluim(employeeId, serviceStartDate, allEmployeeRecords);
   }   

   // For emergency period - check if part of existing cluster
   let isNewCluster = true;
   
   // Check if this is part of existing emergency cluster
   for (let miluim of miluimData) {
       if (miluim.employeeId == employeeId) {
           const miluimEnd = parseExcelDate(miluim.endDate);
           const miluimStart = parseExcelDate(miluim.startDate);
           
           if (miluimEnd < serviceStartDate && miluimStart >= EMERGENCY_START) {
               const serviceMonthStart = getServiceMonthStart(serviceStartDate);
               const daysDiff = (serviceMonthStart - miluimEnd) / (1000 * 60 * 60 * 24);
               
               // If gap is <= 90 days, same cluster
               if (daysDiff <= 90) {
                   isNewCluster = false;
                   break;
               }
           }
       }
   }
   
   // If part of existing cluster, check if need to limit value
   if (!isNewCluster) {
       // Find cluster start date (same logic as in calculateEmergencyValues)
       const employeeMiluim = miluimData
           .filter(m => m.employeeId == employeeId)
           .map(m => ({...m, startDate: parseExcelDate(m.startDate), endDate: parseExcelDate(m.endDate)}))
           .filter(m => m.endDate < serviceStartDate && m.startDate >= EMERGENCY_START)
           .sort((a, b) => b.endDate - a.endDate);
       
       let clusterStartDate = serviceStartDate;
       let checkDate = getServiceMonthStart(serviceStartDate);
       
       for (let prevMiluim of employeeMiluim) {
           const gap = (checkDate - prevMiluim.endDate) / (1000 * 60 * 60 * 24);
           if (gap <= 90) {
               clusterStartDate = prevMiluim.startDate;
              checkDate = getServiceMonthStart(prevMiluim.startDate);
           } else {
               break;
           }
       }
    
       // ?? ùéîåù á-CACHE ìçéùåá òøê J ùì úçéìú äàùëåì
       let clusterJValue;
       const clusterKey = cacheSystem.createKey(employeeId, clusterStartDate);
       
       if (cacheSystem.cache.has(clusterKey)) {
           // ? ÷ç îäîèîåï
           const cachedClusterResult = cacheSystem.cache.get(clusterKey);
           clusterJValue = cachedClusterResult.recommendedValue * 1.2;
           console.log(`? CACHE HIT ìúçéìú àùëåì: ${clusterKey}`);
       } else {
           // fallback - çéùåá øâéì
           const clusterStartCalc = calculateBasicDailyValue(employeeId, clusterStartDate);
           const clusterRecommendedValue = calculateRecommendedValue(employeeId, clusterStartDate, clusterStartCalc.dailyValue);
           clusterJValue = clusterRecommendedValue * 1.2;
           console.log(`?? çéùåá fallback ìúçéìú àùëåì: ${clusterKey}`);
       }
      
       // Only limit if current value is higher than cluster J value AND it's new miluim
       if (recommendedValue > clusterJValue && isNewMiluim) {
           return {
               value: clusterJValue,
               isLocked: true // òøê ðòåì áâìì òøê âáåä
           };
       }
   }
   
   return {
       value: recommendedValue,
       isLocked: false
   };
}
     function calculateEmergencyValues(employeeId, serviceStartDate, continuousValue) {
            if (serviceStartDate < EMERGENCY_START) {
                return {
                    emergencyValue: 0,
                    maxEmergencyValue: 0,
                    emergencyClusterStart: null,
                    isNewCluster: false
                };
            }
            
            // Check if this is start of new emergency cluster
            let isNewCluster = true;
            let clusterStartDate = serviceStartDate;
            
            for (let miluim of miluimData) {
                if (miluim.employeeId == employeeId) {
                    const miluimEnd = parseExcelDate(miluim.endDate);
                    const miluimStart = parseExcelDate(miluim.startDate);
                    
                    if (miluimEnd < serviceStartDate && miluimStart >= EMERGENCY_START) {
                      const serviceMonthStart = getServiceMonthStart(serviceStartDate);
                      const daysDiff = (serviceMonthStart - miluimEnd) / (1000 * 60 * 60 * 24);
                        
                        // If gap is <= 90 days, same cluster
                        if (daysDiff <= 90) {
                    isNewCluster = false;
                    // Don't break - continue to find the real cluster start
                    // Keep going backward to find the actual cluster beginning
}
                    }
                }
            }
            // If not new cluster, find the real cluster start by going backward
if (!isNewCluster) {
    // Create array of all employee miluim before current date
    const employeeMiluim = miluimData
        .filter(m => m.employeeId == employeeId)
        .map(m => ({...m, startDate: parseExcelDate(m.startDate), endDate: parseExcelDate(m.endDate)}))
        .filter(m => m.endDate < serviceStartDate && m.startDate >= EMERGENCY_START)
        .sort((a, b) => b.endDate - a.endDate);
    

   // Go backward to find cluster start
let checkDate = getServiceMonthStart(serviceStartDate);
for (let prevMiluim of employeeMiluim) {
    const gap = (checkDate - prevMiluim.endDate) / (1000 * 60 * 60 * 24);
    if (gap <= 90) {
        clusterStartDate = prevMiluim.startDate;
        checkDate = getServiceMonthStart(prevMiluim.startDate);           
            // If reached pre-emergency period, stop
            if (prevMiluim.startDate < EMERGENCY_START) {
                break;
            }
        } else {
            break;
        }
    }
}
            
            const emergencyValue = isNewCluster ? continuousValue : continuousValue; // Would need cluster start value
            const maxEmergencyValue = emergencyValue * 1.2;
            
            // Apply final limits to max emergency value
            const limitedMaxValue = ApplyFinalLimitsFromCSV(maxEmergencyValue, serviceStartDate);
            
            return {
    emergencyValue,
    maxEmergencyValue: limitedMaxValue,
    emergencyClusterStart: clusterStartDate,  // ⚠️ תמיד להחזיר את תחילת האשכול
    isNewCluster
};
}
function calculateCompulsionContinuous() {
    // קיבוץ לפי עובד
    const employeeGroups = {};
    calculationResults.forEach(result => {
        if (!employeeGroups[result.employeeId]) {
            employeeGroups[result.employeeId] = [];
        }
        employeeGroups[result.employeeId].push(result);
    });
    
    Object.keys(employeeGroups).forEach(employeeId => {
        const employeeData = employeeGroups[employeeId];
        // מיון לפי תאריך התחלה - בדיוק כמו בפונקציה הישנה
        employeeData.sort((a, b) => a.startDate - b.startDate);
        
        let lastCompulsion = 0;
        for (let i = 0; i < employeeData.length; i++) {
            const current = employeeData[i];
            const prev = i > 0 ? employeeData[i-1] : null;
            
            if (prev) {
                const gapDays = (current.startDate - prev.endDate) / (1000 * 60 * 60 * 24);
                if (gapDays <= 1) {
                    // --- רצף ---
                    if (!current.compulsion || current.compulsion === 0) {
                        // אין ערך -> ממשיכים את הערך הקודם
                        current.compulsionContinuous = lastCompulsion;
                    } else {
                        // יש ערך -> משתמשים בו
                        current.compulsionContinuous = current.compulsion;
                        lastCompulsion = current.compulsion;
                    }
                } else {
                    // --- לא רצף ---
                    current.compulsionContinuous = current.compulsion || 0;
                    if (current.compulsion && current.compulsion !== 0) {
                        lastCompulsion = current.compulsion;
                    } else {
                        lastCompulsion = 0; // איפוס חשוב
                    }
                }
            } else {
                // --- התקופה הראשונה ---
                current.compulsionContinuous = current.compulsion || 0;
                if (current.compulsion && current.compulsion !== 0) {
                    lastCompulsion = current.compulsion;
                } else {
                    lastCompulsion = 0;
                }
            }
        }
    });
}
function propagateEmergencyCompulsion4405() {
    console.log("מתחיל הפצת ערכי כפיה חירום 4405...");
    
    // מוצא את כל הערכים הייחודיים בעמודה P עם תחילת האשכול שלהם
    const compulsionValues = new Map(); // Key: עובד-תאריך תחילת אשכול, Value: מידע מלא

    calculationResults.forEach(result => {
        if (result.emergencyCompulsion4405 && result.emergencyCompulsion4405 > 0 && result.emergencyClusterStart) {
            const clusterStartKey = `${result.employeeId}-${result.emergencyClusterStart.getTime()}`;
            compulsionValues.set(clusterStartKey, {
                employeeId: result.employeeId,
                clusterStart: result.emergencyClusterStart,
                compulsionValue: Math.round(result.emergencyCompulsion4405 * 1.2 * 100) / 100
            });
            
            console.log(`נמצא ערך כפיה ${result.emergencyCompulsion4405} עבור עובד ${result.employeeId} לאשכול מתאריך ${formatDate(result.emergencyClusterStart)}`);
        }
    });
    
    // הפץ את הערכים לכל התקופות עם אותה תחילת אשכול של אותו עובד
    compulsionValues.forEach((compulsionData, clusterKey) => {
        let updatedCount = 0;
        
        calculationResults.forEach(result => {
            if (result.employeeId === compulsionData.employeeId &&
                result.emergencyClusterStart && 
                result.emergencyClusterStart.getTime() === compulsionData.clusterStart.getTime()) {
                
                result.emergencyCompulsion4405 = compulsionData.compulsionValue;
                updatedCount++;
            }
        });
        
        console.log(`הופץ ערך ${compulsionData.compulsionValue} ל-${updatedCount} תקופות עבור עובד ${compulsionData.employeeId} עם תחילת אשכול ${formatDate(compulsionData.clusterStart)}`);
    });
    
    console.log("הושלמה הפצת ערכי כפיה חירום 4405");
}
                
// 🔥 הוסף פונקציה לבדיקת תקופות גולשות מקוריות
function hasOriginalCrossMonthPeriods(employeeId) {
    const employeeOriginalPeriods = miluimData.filter(m => m.employeeId == employeeId);
    
    for (let period of employeeOriginalPeriods) {
        if (typeof period.startDate === 'number' && typeof period.endDate === 'number') {
            // השתמש בחישוב הפשוט שעבד
            const resultDate1 = new Date(1900, 0, 1);
            resultDate1.setDate(resultDate1.getDate() + period.startDate - 2);
            const startDate = new Date(resultDate1.getFullYear(), resultDate1.getMonth(), resultDate1.getDate());
            
            const resultDate2 = new Date(1900, 0, 1);
            resultDate2.setDate(resultDate2.getDate() + period.endDate - 2);
            const endDate = new Date(resultDate2.getFullYear(), resultDate2.getMonth(), resultDate2.getDate());
            
            if (startDate.getMonth() !== endDate.getMonth() || 
                startDate.getFullYear() !== endDate.getFullYear()) {
                return true;
            }
        }
    }
    return false;
}
function isCrossMonthService(result) {
    // חפש את הרשומה המתאימה בנתוני המילואים
    const miluimRecord = self.miluimData.find(m => 
        m.employeeId == result.employeeId && 
        Math.abs(parseExcelDate(m.startDate) - result.startDate) < 86400000
    );
    
    // קרא מעמודה 13 (אינדקס 12) - 0 = לא גולש, 1 = גולש
    return miluimRecord?.crossMonth === 1;
}
// 🔥 עדכן את calculateMiluimForEmployeeWithCache
function calculateMiluimForEmployeeWithCache(employeeId) {
    const employeeMiluim = miluimData.filter(m => m.employeeId == employeeId);
    const results = [];
    
    // 🔥 חשב פעם אחת לכל עובד
    const hasCrossMonthPeriods = hasOriginalCrossMonthPeriods(employeeId);
    
    for (let miluim of employeeMiluim) {
        const startDate = parseExcelDate(miluim.startDate);
        const endDate = parseExcelDate(miluim.endDate);
        
        if (!startDate || !endDate) continue;

        const cacheResult = cacheSystem.calculateWithCache(employeeId, startDate);
        
        const result = {
            ...cacheResult,
            endDate: endDate,
            miluimDays: miluim.miluimDays || Math.ceil((endDate - startDate) / (1000 * 60 * 60 * 24)) + 1,
            hasOriginalCrossMonthPeriods: hasCrossMonthPeriods,  // 🔥 הוסף את המאפיין!
            isCrossMonth: miluim.crossMonth === 1 
        };
        
        results.push(result);
    }            
    
    return results;
}
        // File upload handlers
        function setupFileUpload() {
            document.getElementById('excelFile').addEventListener('change', function(e) {
                loadExcelFile(e.target.files[0]);
            });
        }
        
  // 🚀 פונקציה מתוקנת ומושלמת לחישוב מילואים
async function calculateMiluim(config = {}) {
    const {
        employeeIds = null,        // מערך עובדים ספציפיים או null לכולם
        batchSize = 0,            // 0 = ללא batches, >0 = עם batches
        showProgress = false,     // הצגת progress bar
        enableCancel = false,     // אפשרות ביטול
        addEmployeeHeader = false, // header לעובד בודד
        autoDisplayResults = true, // הצגה אוטומטית של תוצאות
        returnResults = false     // החזרת תוצאות במקום הצגה
    } = config;

    // === 1. הכנה ובדיקות ===
    calculationResults = [];
    
    // טיפול בעובדים ספציפיים
    if (employeeIds && employeeIds.length > 0) {
        // שמירת נתונים מקוריים
        if (originalMiluimData.length === 0) {
            originalMiluimData = [...miluimData];
            originalSalaryData = [...salaryData];
            originalAttendanceData = [...attendanceData];
        }

        // סינון לעובדים הנבחרים
        miluimData = originalMiluimData.filter(m => employeeIds.includes(m.employeeId.toString()));
        salaryData = originalSalaryData.filter(s => employeeIds.includes(s.employeeId.toString()));
        attendanceData = originalAttendanceData.filter(a => employeeIds.includes(a.employeeId.toString()));

        // בדיקה שיש נתונים
        if (miluimData.length === 0) {
            document.getElementById('resultsContainer').innerHTML = 
                `<div class="error">לא נמצאו נתוני מילואים לעובד ${employeeIds[0]}</div>`;
            return;
        }
    }

    const uniqueEmployees = [...new Set(miluimData.map(m => m.employeeId))];
    const totalEmployees = uniqueEmployees.length;
    console.log(`🔄 מתחיל חישוב עבור ${totalEmployees} עובדים`);

    // === 2. הצגת Loading ===
    const shouldUseBatches = batchSize > 0 && totalEmployees > batchSize;
    
    if (shouldUseBatches && showProgress) {
        // Progress Bar מתקדם
        document.getElementById('resultsContainer').innerHTML = `
            <div class="loading" style="padding: 40px;">
                <div style="font-size: 1.8em; margin-bottom: 20px;">🔄 מעבד ${totalEmployees} עובדים...</div>
                <div id="progressBar" style="width: 400px; height: 35px; background: #ecf0f1; border-radius: 20px; margin: 20px auto; overflow: hidden;">
                    <div id="progressFill" style="width: 0%; height: 100%; background: linear-gradient(90deg, #3498db, #2ecc71); border-radius: 20px; transition: width 0.3s ease;"></div>
                </div>
                <div id="progressText" style="font-size: 1.3em; margin: 15px 0; color: #2c3e50;">
                    <span id="currentCount">0</span> / <span id="totalCount">${totalEmployees}</span> עובדים
                </div>
                <div id="timeEstimate" style="font-size: 1em; color: #7f8c8d;">זמן משוער: מחשב...</div>
                ${enableCancel ? `<button class="btn" style="background: #e74c3c; margin-top: 20px;" onclick="window.cancelBatchCalculation = true">⛔ בטל</button>` : ''}
            </div>`;
        
        if (enableCancel) window.cancelBatchCalculation = false;
    } else {
        // Loading פשוט
        document.getElementById('resultsContainer').innerHTML = '<div class="loading">🔄 מעבד נתונים...</div>';
    }

    // === 3. הכנת CACHE ===
    cacheSystem.prepareData();

    // === 4. פונקציה מרכזית לעיבוד תוצאות ===
    const processResults = () => {
        if (autoDisplayResults) {
            // Header לעובד בודד
            if (addEmployeeHeader && employeeIds && employeeIds.length === 1) {
                const header = document.createElement('div');
                header.style.cssText = 'background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 20px; margin-bottom: 20px; border-radius: 10px; text-align: center;';
                header.innerHTML = `<h2 style="margin: 0; font-size: 1.5em;">📊 תוצאות עובד ${employeeIds[0]}</h2>`;
                
                setTimeout(() => {
                    const container = document.getElementById('resultsContainer');
                    container.innerHTML = '';
                    container.appendChild(header);
                    displayResults(calculationResults, { 
                        itemsPerPage: calculationResults.length > 100 ? 50 : null 
                    });
                }, 50);
            } else {
                // הצגה רגילה
                displayResults(calculationResults, { 
                    itemsPerPage: calculationResults.length > 100 ? 50 : null 
                });
            }
       
            // עדכון סטטיסטיקות וייצוא
            updateSummaryStats();
            document.getElementById('exportSection').style.display = 'block';
        }

        // שחזור נתונים מקוריים
        if (employeeIds && employeeIds.length > 0) {
            miluimData = originalMiluimData;
            salaryData = originalSalaryData;
            attendanceData = originalAttendanceData;
        }

        console.log(`✅ הושלם! ${calculationResults.length} תוצאות`);
        
        if (returnResults) return calculationResults;
    };

    // === 5. החישוב הראשי ===
    const startTime = performance.now();

    if (shouldUseBatches) {
        // === חישוב עם Batches (עבור מאות/אלפי עובדים) ===
        const batchStartTime = Date.now();
        
        try {
            for (let i = 0; i < uniqueEmployees.length; i += batchSize) {
                // בדיקת ביטול
                if (enableCancel && window.cancelBatchCalculation) {
                    console.log('❌ חישוב בוטל על ידי המשתמש');
                    return;
                }

                // עיבוד הבאצ' הנוכחי
                const batch = uniqueEmployees.slice(i, i + batchSize);
                
                for (let employeeId of batch) {
                    const results = calculateMiluimForEmployeeWithCache(employeeId);
                    calculationResults.push(...results);
                }
                
                const processedCount = Math.min(i + batchSize, totalEmployees);
                
                // עדכון Progress Bar
                if (showProgress) {
                    const progressPercent = (processedCount / totalEmployees) * 100;
                    const progressFill = document.getElementById('progressFill');
                    const currentCount = document.getElementById('currentCount');
                    const timeEstimate = document.getElementById('timeEstimate');
                    
                    if (progressFill) progressFill.style.width = progressPercent + '%';
                    if (currentCount) currentCount.textContent = processedCount;
                    
                    // חישוב זמן משוער
                    if (timeEstimate && processedCount > 0) {
                        const elapsed = Date.now() - batchStartTime;
                        const avgTime = elapsed / processedCount;
                        const remaining = (avgTime * (totalEmployees - processedCount)) / 1000;
                        
                        if (remaining > 60) {
                            const min = Math.floor(remaining / 60);
                            const sec = Math.floor(remaining % 60);
                            timeEstimate.textContent = `זמן משוער: ${min}:${sec.toString().padStart(2, '0')}`;
                        } else {
                            timeEstimate.textContent = `זמן משוער: ${Math.floor(remaining)} שניות`;
                        }
                    }
                }
                
                // מנוחה קצרה לדפדפן
                await new Promise(resolve => setTimeout(resolve, 30));
            }
            
            // ✅ התיקון: חישוב עמודה O אחרי שכל הנתונים מוכנים
            calculateCompulsionContinuous();
            console.log('ערכי כפייה רציפה חושבו ונוספו לטבלה');
            propagateEmergencyCompulsion4405(); // 
            console.log('ערכי כפיה חירום 4405 הופצו לאשכולות');
            
            // סיום חישוב עם Batches - הצגת תוצאות
            processResults();
            
        } catch (error) {
            console.error('שגיאה בחישוב Batches:', error);
            document.getElementById('resultsContainer').innerHTML = 
                `<div class="error">שגיאה בחישוב: ${error.message}</div>`;
        }
        
    } else {
        // === חישוב רגיל (עבור מאות עובדים) ===
        setTimeout(() => {
            try {
                for (let employeeId of uniqueEmployees) {
                    const results = calculateMiluimForEmployeeWithCache(employeeId);
                    calculationResults.push(...results);
                }
                
                // ✅ התיקון: חישוב עמודה O אחרי שכל הנתונים מוכנים
                calculateCompulsionContinuous();
                console.log('ערכי כפייה רציפה חושבו ונוספו לטבלה');
            propagateEmergencyCompulsion4405(); // 
            console.log('ערכי כפיה חירום 4405 הופצו לאשכולות');
                
                // הצגת תוצאות
                processResults();
                
            } catch (error) {
                console.error('שגיאה בחישוב רגיל:', error);
                document.getElementById('resultsContainer').innerHTML = 
                    `<div class="error">שגיאה בחישוב: ${error.message}</div>`;
            }
        }, 100);
    }

    return calculationResults;
}

// === דוגמאות שימוש ===

// 1. חישוב רגיל לכל העובדים
// calculateMiluim();

// 2. חישוב עם progress bar למאות עובדים
// calculateMiluim({ batchSize: 20, showProgress: true });

// 3. חישוב עם אפשרות ביטול לאלפי עובדים  
// calculateMiluim({ batchSize: 50, showProgress: true, enableCancel: true });

// 4. חישוב לעובד ספציפי
// calculateMiluim({ employeeIds: ['123456789'], addEmployeeHeader: true });

// 5. החזרת תוצאות ללא הצגה
// const results = await calculateMiluim({ returnResults: true });
        function loadExcelFile(file) {
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const data = new Uint8Array(e.target.result);
                    const workbook = XLSX.read(data, { type: 'array' });
                    
                    console.log('Available sheets:', workbook.SheetNames);
                    
                    // Reset data
                    miluimData = [];
                    salaryData = [];
                    attendanceData = [];
                    
                    let sheetsLoaded = 0;
                    
                    // Try to load each sheet - flexible sheet naming
                    for (let i = 0; i < Math.min(3, workbook.SheetNames.length); i++) {
                        const sheetName = workbook.SheetNames[i];
                        const worksheet = workbook.Sheets[sheetName];
                        const jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1 });
                        
                        if (jsonData.length > 1) { // Has data beyond header
                            if (i === 0) {
                                // First sheet - Miluim data
                                parseData(jsonData, 'miluim');
                                updateSheetStatus('sheet1Status', true, `📊 גליון מילואים: ✅ (${miluimData.length} רשומות)`);
                                sheetsLoaded++;
                            } else if (i === 1) {
                                // Second sheet - Salary data
                                parseData(jsonData, 'salary');
                                updateSheetStatus('sheet2Status', true, `💰 גליון שכר: ✅ (${salaryData.length} רשומות)`);
                                sheetsLoaded++;
                            } else if (i === 2) {
                                // Third sheet - Attendance data
                                parseData(jsonData, 'attendance');
                                updateSheetStatus('sheet3Status', true, `📅 גליון נוכחות: ✅ (${attendanceData.length} רשומות)`);
                                sheetsLoaded++;
                            }
                        }
                    }
                    
                    document.getElementById('sheetsStatus').style.display = 'block';
                    
                    if (sheetsLoaded === 3) {
                        updateUploadStatus(true);
                        showSuccessMessage(`הקובץ נטען בהצלחה! ${miluimData.length} תקופות מילואים, ${salaryData.length} רשומות שכר, ${attendanceData.length} רשומות נוכחות`);
                    } else {
                        showErrorMessage(`נטענו רק ${sheetsLoaded} מתוך 3 גליונות. אנא ודא שהקובץ מכיל 3 גליונות עם נתונים.`);
                    }
                    
                    checkCalculateButton();
                } catch (error) {
                    console.error('Error loading file:', error);
                    showErrorMessage('שגיאה בטעינת הקובץ: ' + error.message);
                }
            };
            reader.readAsArrayBuffer(file);
        }

        function updateSheetStatus(elementId, success, text) {
            const element = document.getElementById(elementId);
            element.textContent = text;
            if (success) {
                element.classList.add('sheet-loaded');
            } else {
                element.classList.remove('sheet-loaded');
            }
        }

        function showSuccessMessage(message) {
            const container = document.querySelector('.upload-section');
            const existing = container.querySelector('.success, .error');
            if (existing) existing.remove();
            
            const msgDiv = document.createElement('div');
            msgDiv.className = 'success';
            msgDiv.textContent = message;
            container.appendChild(msgDiv);
            
            setTimeout(() => msgDiv.remove(), 5000);
        }

        function showErrorMessage(message) {
            const container = document.querySelector('.upload-section');
            const existing = container.querySelector('.success, .error');
            if (existing) existing.remove();
            
            const msgDiv = document.createElement('div');
            msgDiv.className = 'error';
            msgDiv.textContent = message;
            container.appendChild(msgDiv);
        }

        function parseData(jsonData, type) {
            // Skip header row
            const dataRows = jsonData.slice(1);
            
            switch (type) {
                case 'miluim':
                    miluimData = dataRows.map(row => ({
                        employeeId: row[0],
                        startDate: row[1],
                        endDate: row[2],
                        days: row[3],
                        paidAmount: parseFloat(row[11]),
                        compulsion: parseFloat(row[12]),
                        crossMonth:row[13],
                        emergencyCompulsion4405: parseFloat(row[14])

                    })).filter(item => item.employeeId);
                    break;
                    
                case 'salary':
                    salaryData = dataRows.map(row => ({
                        employeeId: row[0],
                        monthYear: row[1],
                        bruto: row[2]
                    })).filter(item => item.employeeId);
                    break;
                    
               case 'attendance':
                    attendanceData = dataRows.map(row => ({
                    employeeId: row[0],
                    monthYear: row[1],
                    workDays: row[2],      // עמודה C - מילואים רגילים  
                    workDaysNew: row[3]    // עמודה D - מילואים חדשים
                 })).filter(item => item.employeeId);
                break;
            }
        }

        function updateUploadStatus(success) {
            const btn = document.getElementById('excelBtn');
            const card = document.querySelector('.upload-card');
            
            if (success) {
                btn.textContent = '✅ קובץ נטען בהצלחה';
                btn.classList.add('success');
                card.classList.add('uploaded');
            } else {
                btn.textContent = 'בחר קובץ אקסל';
                btn.classList.remove('success');
                card.classList.remove('uploaded');
            }
        }

        function checkCalculateButton() {
    const hasAllFiles = miluimData.length > 0 && salaryData.length > 0 && attendanceData.length > 0;
    document.getElementById('calculateBtn').disabled = !hasAllFiles;
    
    // הצג כפתור עובד בודד אם יש נתונים
    if (hasAllFiles) {
        document.getElementById('singleEmployeeBtn').style.display = 'inline-block';
    }
}
// פונקציה להצגת/הסתרת שדה הקלדת עובד
function showEmployeeSelector() {
    const selectorDiv = document.getElementById('employeeSelectorDiv');
    
    // הצג/הסתר את השדה
    if (selectorDiv.style.display === 'none' || selectorDiv.style.display === '') {
        selectorDiv.style.display = 'block';
        document.getElementById('employeeInput').focus();
    } else {
        selectorDiv.style.display = 'none';
    }
    // שמור את הנתונים המקוריים
if (hasAllFiles && originalMiluimData.length === 0) {
    originalMiluimData = [...miluimData];
    originalSalaryData = [...salaryData];
    originalAttendanceData = [...attendanceData];
}
    
}

function validateEmployee() {
    const input = document.getElementById('employeeInput').value.trim();
    const validation = document.getElementById('employeeValidation');
    const calculateBtn = document.getElementById('calculateSingleBtn');
    
    if (!input) {
        validation.textContent = '';
        calculateBtn.disabled = true;
        return;
    }
    
    // בדוק אם העובד קיים - ודא שהבדיקה נעשית נכון
    const employeeExists = miluimData.some(m => {
        // השווה גם כמספר וגם כמחרוזת
        return m.employeeId == input || m.employeeId === input.toString();
    });
    
    if (employeeExists) {
        validation.textContent = '✓ העובד נמצא';
        validation.style.color = '#27ae60';
        calculateBtn.disabled = false;
    } else {
        validation.textContent = '✗ עובד לא נמצא';
        validation.style.color = '#e74c3c';
        calculateBtn.disabled = true;
    }
    
    // הדפס לקונסול לבדיקה
    console.log(`בדיקת עובד ${input}: ${employeeExists ? 'נמצא' : 'לא נמצא'}`);
    console.log('מספר עובדים כולל:', miluimData.length);
}



// פונקציה לייצוא עובד בודד
function exportSingleEmployee(employeeId) {
    if (!window.singleEmployeeResults) return;
    
    const exportData = window.singleEmployeeResults.map(r => ({
        'מספר עובד': employeeId,
        'תחילת שירות': formatDate(r.serviceStartDate),
        'סיום שירות': formatDate(r.serviceEndDate),
        'ימי שירות': r.serviceDays,
        'ערך יומי בסיסי': r.basicDailyValue,
        'ערך מומלץ': r.recommendedValue,
        'סטטוס': r.finalStatus || 'מחושב'
    }));
    
    const ws = XLSX.utils.json_to_sheet(exportData);
    const wb = XLSX.utils.book_new();
    XLSX.utils.book_append_sheet(wb, ws, `עובד_${employeeId}`);
    XLSX.writeFile(wb, `miluim_employee_${employeeId}_${new Date().toISOString().split('T')[0]}.xlsx`);
}

function backToAllEmployees() {
    // נקה את שדה העובד
    document.getElementById('employeeInput').value = '';
    document.getElementById('employeeValidation').textContent = '';
    document.getElementById('calculateSingleBtn').disabled = true;
    document.getElementById('employeeSelectorDiv').style.display = 'none';
    
    // חשב מחדש לכל העובדים
    const uniqueEmployees = [...new Set(miluimData.map(m => m.employeeId))];
if (uniqueEmployees.length > 100) {
    calculateMiluim({ batchSize: 20, showProgress: true, enableCancel: true });
} else {
    calculateMiluim({ batchSize: 0 });
}
}


        function getRowClass(result) {
            let classes = [];
            
            if (result.isNewMiluim) {
                classes.push('new-miluim');
            }
            
            if (result.isNewCluster && result.startDate >= EMERGENCY_START) {
                classes.push('emergency-cluster');
            }
            
            return classes.join(' ');
        }

        function updateSummaryStats() {
            const uniqueEmployees = new Set(calculationResults.map(r => r.employeeId)).size;
            const totalPeriods = calculationResults.length;
            const totalDays = calculationResults.reduce((sum, r) => sum + r.miluimDays, 0);
            const totalPayment = calculationResults.reduce((sum, r) => sum + (r.continuousValue * r.miluimDays), 0);
            
            document.getElementById('totalEmployees').textContent = uniqueEmployees;
            document.getElementById('totalPeriods').textContent = totalPeriods;
            document.getElementById('totalDays').textContent = totalDays;
            document.getElementById('totalPayment').textContent = formatCurrency(totalPayment);
            
            document.getElementById('summaryStats').style.display = 'grid';
        }
   function getExtendedCalculationDetails(employeeId, serviceStartDate) {
    const serviceMonth = new Date(serviceStartDate.getFullYear(), serviceStartDate.getMonth(), 1);
    
    // בדיקה ראשונית - 3 החודשים האחרונים לימי עבודה
    const month1 = new Date(serviceMonth.getFullYear(), serviceMonth.getMonth() - 1, 1);
    const month2 = new Date(serviceMonth.getFullYear(), serviceMonth.getMonth() - 2, 1);
    const month3 = new Date(serviceMonth.getFullYear(), serviceMonth.getMonth() - 3, 1);
    
    // בדיקת ימי עבודה לקביעת סוג החישוב
    const workDays1 = GetWorkDaysForMonth(employeeId, month1, serviceStartDate);
    const workDays2 = GetWorkDaysForMonth(employeeId, month2, serviceStartDate);
    const workDays3 = GetWorkDaysForMonth(employeeId, month3, serviceStartDate);
    const totalWorkDays = workDays1 + workDays2 + workDays3;
    
    // *** השינוי המרכזי: פיצול בין ברוטו וימי עבודה ***
    
    // ימי עבודה - תמיד 3 החודשים האחרונים
    let monthsForWorkDays = [month3, month2, month1];
    
    // ברוטו - תלוי בסוג החישוב
    let monthsForBruto = [month3, month2, month1]; // ברירת מחדל
    let calculationType = 'רגיל';
    
    // אם זה חישוב חלופי - הברוטו יילקח מ-3 הטובים, אבל ימי עבודה נשארים 3 אחרונים
    if (totalWorkDays < 60) {
        calculationType = 'חלופי';
        
        // בניית רשימת 6 חודשים עם הברוטו שלהם - רק לברוטו
        const allMonths = [];
        for (let i = 1; i <= 6; i++) {
            const month = new Date(serviceMonth.getFullYear(), serviceMonth.getMonth() - i, 1);
            const bruto = GetBrutoForMonth(employeeId, month);
            allMonths.push({
                date: month,
                bruto: bruto
            });
        }
        
        // בחירת 3 החודשים עם הברוטו הגבוה ביותר - רק לברוטו
        monthsForBruto = allMonths
            .sort((a, b) => b.bruto - a.bruto)  // מיון לפי ברוטו יורד
            .slice(0, 3)                        // 3 הראשונים
            .map(m => m.date)                   // רק התאריכים
            .sort((a, b) => a - b);             // מיון לפי תאריך עולה
    }
    
    // בניית פירוט ברוטו (לפי החודשים שנבחרו)
    const brutoBTLDetails = [];
    let totalBrutoBTL = 0;
    
    monthsForBruto.forEach(month => {
        // ברוטו מותאם (עם מינימום ביטוח לאומי)
        const adjustedBruto = GetBrutoForMonth(employeeId, month);
        
        // ברוטו מקורי (לפני התאמה)
        const monthStart = new Date(month.getFullYear(), month.getMonth(), 1);
        const monthEnd = new Date(month.getFullYear(), month.getMonth() + 1, 0);
        
        let originalBruto = 0;
        for (let salary of salaryData) {
            if (salary.employeeId == employeeId) {
                const salaryDate = parseExcelDate(salary.monthYear);
                if (salaryDate && salaryDate >= monthStart && salaryDate <= monthEnd) {
                    originalBruto = Math.max(originalBruto, salary.bruto || 0);
                }
            }
        }
        
        // הוספה לפירוט ברוטו
        brutoBTLDetails.push({
            month: (month.getMonth() + 1) + '/' + month.getFullYear(),
            original: originalBruto,
            adjusted: adjustedBruto,
            wasAdjusted: adjustedBruto > originalBruto
        });
        
        totalBrutoBTL += adjustedBruto;
    });
    
    // בניית פירוט ימי עבודה (תמיד 3 חודשים אחרונים)
    const workDaysDetails = [];
    let totalWorkDaysCalculated = 0;
    
    monthsForWorkDays.forEach(month => {
        const workDays = GetWorkDaysForMonth(employeeId, month, serviceStartDate);
        
        workDaysDetails.push({
            month: (month.getMonth() + 1) + '/' + month.getFullYear(),
            workDays: workDays
        });
        
        totalWorkDaysCalculated += workDays;
    });
    
    return {
        brutoBTLDetails: brutoBTLDetails,
        totalBrutoBTL: totalBrutoBTL,
        workDaysDetails: workDaysDetails,
        totalWorkDays: totalWorkDaysCalculated,
        calculationType: calculationType,
        monthsUsedForBruto: monthsForBruto.length,  // למעקב
        monthsUsedForWorkDays: monthsForWorkDays.length  // למעקב
    };
}
function displayResults(data = calculationResults, options = {}) {
    const {
        page = 1,
        itemsPerPage = null,
        showPagination = true,
        title = null,
        subtitle = null,
        showStats = true,
        showExport = true,
        isFiltered = false,
        isSingleEmployee = false,
        employeeId = null,
        sourceData = calculationResults
    } = options;
    
    // שמירת הנתונים הנוכחיים
    currentDisplayData = data;
    currentDisplayOptions = options;
    
    const container = document.getElementById('resultsContainer');
    
    if (!data || data.length === 0) {
        let emptyMessage = 'לא נמצאו תוצאות';
        if (isFiltered) {
            emptyMessage = 'לא נמצאו תוצאות לפי הסינון שנבחר';
        }
        container.innerHTML = `<div class="error">${emptyMessage}</div>`;
        return;
    }
    
    let pageData = data;
    let totalPages = 1;
    let start = 0;
    let end = data.length;
    
    if (itemsPerPage && data.length > itemsPerPage) {
        totalPages = Math.ceil(data.length / itemsPerPage);
        start = (page - 1) * itemsPerPage;
        end = start + itemsPerPage;
        pageData = data.slice(start, end);
    }
    
    let html = '';
    
    if (title) {
        html += `
            <div style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 20px; margin-bottom: 20px; border-radius: 10px; text-align: center;">
                <h2 style="margin: 0; font-size: 1.5em;">${title}</h2>
                ${subtitle ? `<p style="margin: 5px 0 0 0; opacity: 0.9;">${subtitle}</p>` : ''}
            </div>
        `;
    }
    
    if (isSingleEmployee && employeeId) {
        const totalPeriods = data.length;
        const totalDays = data.reduce((sum, r) => sum + (r.serviceDays || r.miluimDays || 0), 0);
        const totalPayment = data.reduce((sum, r) => sum + ((r.continuousValue || 0) * (r.miluimDays || 0)), 0);
        
        html += `
            <div class="summary" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px; margin-bottom: 20px;">
                <div class="summary-card" style="background: #f8f9fa; padding: 15px; border-radius: 8px; text-align: center;">
                    <div class="summary-label" style="color: #666; font-size: 0.9em;">סך תקופות</div>
                    <div class="summary-value" style="font-size: 1.5em; font-weight: bold; color: #2c3e50;">${totalPeriods}</div>
                </div>
                <div class="summary-card" style="background: #f8f9fa; padding: 15px; border-radius: 8px; text-align: center;">
                    <div class="summary-label" style="color: #666; font-size: 0.9em;">סך ימי שירות</div>
                    <div class="summary-value" style="font-size: 1.5em; font-weight: bold; color: #2c3e50;">${totalDays}</div>
                </div>
                <div class="summary-card" style="background: #f8f9fa; padding: 15px; border-radius: 8px; text-align: center;">
                    <div class="summary-label" style="color: #666; font-size: 0.9em;">סך תשלום</div>
                    <div class="summary-value" style="font-size: 1.5em; font-weight: bold; color: #27ae60;">${formatCurrency(totalPayment)}</div>
                </div>
            </div>
        `;
    }
    
    html += `
        <div class="results-table">
            <table>
                <thead>
                    <tr>
                        <th>עובד</th>
                        <th>תחילה</th>
                        <th>סיום</th>
                        <th>ימים</th>
                        <th>E - ערך בסיסי</th>
                        <th>F - ערך מומלץ</th>
                        <th>G - ערך רציף</th>
                        <th>I - חירום 90</th>
                        <th>J - מקס 120%</th>
                        <th>K - תחילת אשכול</th>
                        <th>סך תשלום</th>
                        <th>פירוט</th>
                        <th>L-ערך בשכר</th>
                        <th>M-פער</th>
                        <th>N-ערך כפייה<th>
                        <th>O -כפייה רציפה <th>
                        <th>P - כפייה חירום 4405</th>

                    </tr>
                </thead>
                <tbody>
    `;
    
    pageData.forEach((result, index) => {
        let correctIndex;
        if (itemsPerPage) {
            correctIndex = start + index;
        } else if (isFiltered) {
            correctIndex = sourceData.findIndex(r => 
                r.employeeId === result.employeeId && 
                r.startDate.getTime() === result.startDate.getTime()
            );
        } else {
            correctIndex = index;
        }
        
        const rowClass = getRowClass ? getRowClass(result) : '';
        
        html += `
            <tr class="${rowClass}">
                <td><strong>${result.employeeId}</strong></td>
                <td>${formatDate(result.startDate)}</td>
                <td>${formatDate(result.endDate)}</td>
                <td>${result.miluimDays || result.serviceDays || 0}</td>
                <td class="${result.calculationType === 'חלופי' ? 'alternative-calc' : ''}">${result.basicValue ? result.basicValue.toFixed(2) : '0'}</td>
                <td>${result.recommendedValue ? result.recommendedValue.toFixed(2) : '0'}</td>
                <td class="${result.limitedByNewMiluim || result.isValueLocked ? 'locked-value' : ''}">${result.continuousValue ? result.continuousValue.toFixed(2) : '0'} ${result.isValueLocked ? '🔒' : ''}</td>
                <td>${result.emergencyValue > 0 ? result.emergencyValue.toFixed(2) : '-'}</td>
                <td>${result.maxEmergencyValue > 0 ? result.maxEmergencyValue.toFixed(2) : '-'}</td>
                <td>${result.emergencyClusterStart ? formatDate(result.emergencyClusterStart) : '-'}</td>
                <td><strong>${formatCurrency((result.continuousValue || 0) * (result.miluimDays || 0))}</strong></td>
                <td><button class="details-btn" onclick="showDetails(${correctIndex})">פירוט</button></td>
                <td>${result.paidAmount || 0}</td>
                <td class="amount-difference ${((result.paidAmount || 0) - (result.continuousValue || 0)) > 0 ? 'positive-diff' : 'negative-diff'}">${((result.paidAmount || 0) - (result.continuousValue || 0)).toFixed(0)}</td>
                <td>${result.compulsion  || 0}</td>
                <td>${result.compulsionContinuous || 0}</td>
                <td>${result.emergencyCompulsion4405 || 0}</td> 
            </tr>
        `;
    });
    
    html += `
                </tbody>
            </table>
        </div>
    `;
    
    if (isFiltered || isSingleEmployee || itemsPerPage) {
        html += `
            <div style="margin-top: 15px; padding: 10px; background: #f0f0f0; border-radius: 5px; text-align: center;">
                <strong>מציג ${pageData.length} מתוך ${data.length} תוצאות</strong>
                ${isFiltered && data.length < sourceData.length ? 
                    '<button class="btn" onclick="clearFilters()" style="margin-right: 10px; padding: 5px 15px; font-size: 0.9em;">נקה סינון</button>' : 
                    ''
                }
                ${isSingleEmployee ? 
                    `<button class="btn" onclick="backToAllEmployees()" style="margin-right: 10px; padding: 5px 15px; font-size: 0.9em;">חזור לכל העובדים</button>
                     <button class="btn" onclick="exportSingleEmployee('${employeeId}')" style="background: #27ae60; margin-right: 10px; padding: 5px 15px; font-size: 0.9em;">📄 יצא לאקסל</button>` : 
                    ''
                }
            </div>
        `;
    }
    
    container.innerHTML = html;
    
    // הכפתורים החדשים שלא יגרמו לשגיאות
    if (itemsPerPage && showPagination && totalPages > 1) {
        const paginationDiv = document.createElement('div');
        paginationDiv.style.cssText = 'text-align: center; margin: 20px 0; padding: 20px; background: #f8f9fa; border-radius: 10px;';
        
        paginationDiv.innerHTML = `
            <div style="margin-bottom: 15px; font-size: 1.1em; font-weight: bold;">
                מציג ${start + 1}-${Math.min(end, data.length)} מתוך ${data.length} תוצאות
            </div>
            <div style="margin-bottom: 15px;">
                ${page > 1 ? `<button class="btn" onclick="navigateToPage(${page-1})" style="margin: 0 5px;">⬅️ עמוד קודם</button>` : ''}
                <span style="margin: 0 15px; font-size: 1.1em; font-weight: bold;">עמוד ${page} מתוך ${totalPages}</span>
                ${page < totalPages ? `<button class="btn" onclick="navigateToPage(${page+1})" style="margin: 0 5px;">עמוד הבא ➡️</button>` : ''}
            </div>
            <div>
                <button class="btn" style="background: #27ae60; margin: 0 5px;" onclick="exportToExcel()">
                    📥 יצא הכל לאקסל (כל ${sourceData.length} התוצאות)
                </button>
                <button class="btn" style="background: #3498db; margin: 0 5px;" onclick="changeItemsPerPage(50)">
                    50 בעמוד
                </button>
                <button class="btn" style="background: #3498db; margin: 0 5px;" onclick="changeItemsPerPage(100)">
                    100 בעמוד
                </button>
                <button class="btn" style="background: #3498db; margin: 0 5px;" onclick="changeItemsPerPage(200)">
                    200 בעמוד
                </button>
            </div>
        `;
        
        container.appendChild(paginationDiv);
    }
    
    if (showStats && typeof updateSummaryStats === 'function') {
        updateSummaryStats(data);
    }
    
    if (showExport) {
        const exportSection = document.getElementById('exportSection');
        if (exportSection) exportSection.style.display = 'block';
    }
    
    if (isSingleEmployee) {
        window.singleEmployeeResults = data;
    }
}

// 🔧 הוסף 3 פונקציות קטנות אלה:
function navigateToPage(newPage) {
    const newOptions = { ...currentDisplayOptions, page: newPage };
    displayResults(currentDisplayData, newOptions);
}

function changeItemsPerPage(newItemsPerPage) {
    const newOptions = { ...currentDisplayOptions, itemsPerPage: newItemsPerPage, page: 1 };
    displayResults(currentDisplayData, newOptions);
}

console.log('🔧 תיקון pagination טעון!');

// פונקציות עזר
function updateSummaryStats(data = calculationResults) {
    const uniqueEmployees = new Set(data.map(r => r.employeeId)).size;
    const totalPeriods = data.length;
    const totalDays = data.reduce((sum, r) => sum + (r.miluimDays || 0), 0);
    const totalPayment = data.reduce((sum, r) => sum + ((r.continuousValue || 0) * (r.miluimDays || 0)), 0);
    
    const statsElements = {
        totalEmployees: document.getElementById('totalEmployees'),
        totalPeriods: document.getElementById('totalPeriods'),
        totalDays: document.getElementById('totalDays'),
        totalPayment: document.getElementById('totalPayment')
    };
    
    if (statsElements.totalEmployees) statsElements.totalEmployees.textContent = uniqueEmployees;
    if (statsElements.totalPeriods) statsElements.totalPeriods.textContent = totalPeriods;
    if (statsElements.totalDays) statsElements.totalDays.textContent = totalDays;
    if (statsElements.totalPayment) statsElements.totalPayment.textContent = formatCurrency(totalPayment);
    
    const summaryStats = document.getElementById('summaryStats');
    if (summaryStats) summaryStats.style.display = 'grid';
}
function showDetails(index) {
    const result = calculationResults[index];
    
    // הפונקציה getExtendedCalculationDetails שלך (תביא את הנתונים החסרים)
    const extendedDetails = getExtendedCalculationDetails(result.employeeId, result.startDate);
  
    // בניית הפירוט המורחב שלך (מתוקן)
    let extendedDetailsHtml = '';
    if (extendedDetails) {
        extendedDetailsHtml = `
            <div class="calculation-step">
                <div class="step-title">פירוט מורחב - ברוטו ביטוח לאומי וימי עבודה ✅</div>
                <div class="step-detail">
                    <h4>ברוטו בפועל ששימש לחישוב:</h4>
                    <table style="width: 100%; border-collapse: collapse; margin: 10px 0; font-size: 14px;">
                        <tr style="background: #f0f0f0; font-weight: bold;">
                            <th style="border: 1px solid #ddd; padding: 8px;">חודש</th>
                            <th style="border: 1px solid #ddd; padding: 8px;">ברוטו מקורי</th>
                            <th style="border: 1px solid #ddd; padding: 8px;">ברוטו לביטוח לאומי</th>
                            <th style="border: 1px solid #ddd; padding: 8px;">הותאם</th>
                        </tr>`;
        
        extendedDetails.brutoBTLDetails.forEach(month => {
            extendedDetailsHtml += `
                <tr>
                    <td style="border: 1px solid #ddd; padding: 8px; text-align: center;">${month.month}</td>
                    <td style="border: 1px solid #ddd; padding: 8px; text-align: center;">${month.original.toFixed(2)} ₪</td>
                    <td style="border: 1px solid #ddd; padding: 8px; text-align: center; ${month.wasAdjusted ? 'background: #fff3cd;' : ''}">${month.adjusted.toFixed(2)} ₪</td>
                    <td style="border: 1px solid #ddd; padding: 8px; text-align: center;">${month.wasAdjusted ? 'V' : ''}</td>
                </tr>`;
        });
        
        extendedDetailsHtml += `
                    </table>
                    <p><strong>סה"כ ברוטו לביטוח לאומי: ${extendedDetails.totalBrutoBTL.toFixed(2)} ₪</strong></p>
                    
                    <h4>ימי עבודה ב-90 ימים שקדמו לשירות (לפי גיליון 1857):</h4>
                    <table style="width: 100%; border-collapse: collapse; margin: 10px 0; font-size: 14px;">
                        <tr style="background: #f0f0f0; font-weight: bold;">
                            <th style="border: 1px solid #ddd; padding: 8px;">חודש</th>
                            <th style="border: 1px solid #ddd; padding: 8px;">ימי עבודה בפועל</th>
                        </tr>`;
        
        extendedDetails.workDaysDetails.forEach(month => {
            extendedDetailsHtml += `
                <tr>
                    <td style="border: 1px solid #ddd; padding: 8px; text-align: center;">${month.month}</td>
                    <td style="border: 1px solid #ddd; padding: 8px; text-align: center;">${month.workDays}</td>
                </tr>`;
        });
        
        extendedDetailsHtml += `
                    </table>
                    <p><strong>סה"כ ימי עבודה: ${extendedDetails.totalWorkDays} ימים</strong></p>
                    <p><strong>סוג חישוב: ${extendedDetails.calculationType}</strong></p>
                </div>
            </div>`;
    }
    
    // **החלק המתוקן - עם השדות הנכונים שקיימים ב-result**
    let html = `
        <h2>פירוט חישוב מפורט ✅</h2>
        <h3>עובד ${result.employeeId} | ${formatDate(result.startDate)} - ${formatDate(result.endDate)}</h3>
        
        ${extendedDetailsHtml}
        
        <div class="calculation-step">
            <div class="step-title">שלב 1: איסוף נתוני שכר ונוכחות</div>
            <div class="step-detail">
                <strong>סוג חישוב:</strong> ${result.calculationType || 'לא זמין'}<br>
                <strong>ימי עבודה ב-3 חודשים:</strong> ${extendedDetails?.totalWorkDays || 'לא זמין'}<br>
                <strong>סה"כ ברוטו (3 חודשים):</strong> ${extendedDetails?.totalBrutoBTL ? formatCurrency(extendedDetails.totalBrutoBTL) : 'לא זמין'}
                ${result.calculationType === 'חלופי' ? '<br><span style="color: #e74c3c; font-weight: bold;">אזהרה: פחות מ-60 ימי עבודה - מעבר לחישוב חלופי</span>' : ''}
            </div>
        </div>
        
        <div class="calculation-step">
            <div class="step-title">שלב 2: חישוב ערך יומי בסיסי (Column E)</div>
            <div class="step-detail">
                ערך גולמי: ${extendedDetails?.totalBrutoBTL ? (extendedDetails.totalBrutoBTL / 90).toFixed(2) : 'לא זמין'} ₪<br>
                <strong>ערך לאחר הגבלות:</strong> ${result.basicValue ? result.basicValue.toFixed(2) : 'לא זמין'} ₪
            </div>
        </div>
        
        <div class="calculation-step">
            <div class="step-title">שלב 3: ערך מומלץ 60 ימים (Column F)</div>
            <div class="step-detail">
                ${result.startDate >= new Date('2025-05-01') ? 'מילואים חדשים - לא בודק שירות קודם' : 'בדיקת שירות קודם ב-60 ימים אחרונים'}<br>
                <strong>ערך מומלץ:</strong> ${result.recommendedValue ? result.recommendedValue.toFixed(2) : 'לא זמין'} ₪
            </div>
        </div>
        
        <div class="calculation-step">
            <div class="step-title">שלב 4: ערך רציף (Column G) ${result.isValueLocked ? '🔒 נעול' : ''}</div>
            <div class="step-detail ${result.isValueLocked ? 'locked-value' : ''}">
                ${result.isValueLocked ? 'נעילת ערך למילואים חדשים<br>' : ''}
                <strong>ערך רציף סופי:</strong> ${result.continuousValue ? result.continuousValue.toFixed(2) : 'לא זמין'} ₪<br>
                ${result.startDate >= new Date('2023-10-07') ? 'חל לוגיקת מילואי חירום' : 'מילואים רגילים'}
                ${result.isValueLocked ? '<br><span style="color: #ff9800; font-weight: bold;">ערך הוגבל עבור מילואים חדשים למקסימום 120% של תחילת האשכול</span>' : ''}
                ${result.emergencyClusterStart ? '<br><strong>תחילת אשכול חירום:</strong> ' + formatDate(result.emergencyClusterStart) : ''}
                ${result.emergencyValue > 0 ? '<br><strong>ערך חירום 90:</strong> ' + result.emergencyValue.toFixed(2) + ' ₪' : ''}
            </div>
        </div>
        
        <div class="calculation-step" style="background: #e8f5e8; border-right-color: #4caf50;">
            <div class="step-title">תוצאה סופית ✅</div>
            <div class="step-detail">
                <strong>ימי מילואים:</strong> ${result.miluimDays || 'לא זמין'}<br>
                <strong>ערך יומי סופי:</strong> ${result.continuousValue ? result.continuousValue.toFixed(2) : 'לא זמין'} ₪<br>
                <strong>סה"כ תשלום:</strong> ${result.continuousValue && result.miluimDays ? formatCurrency(result.continuousValue * result.miluimDays) : 'לא זמין'}
                ${result.maxEmergencyValue > 0 ? 
                    '<br><strong>תשלום חירום מקסימלי:</strong> ' + formatCurrency(result.maxEmergencyValue * result.miluimDays) : ''}
            </div>
        </div>
    `;
    
    document.getElementById('detailsContent').innerHTML = html;
    document.getElementById('detailsModal').style.display = 'block';
}
      // Export functionality - מעודכן עם ערך כפייה רצוף
function exportToExcel() {
    // יצירת הנתונים המסוננים בזמן הייצוא
    let dataToExport = [...calculationResults];
    
    // החל אותן סינונים שקיימים במממשק
    const employeeFilter = document.getElementById('employeeFilter').value.trim();
    const yearFilter = document.getElementById('yearFilter').value;
    const miluimTypeFilter = document.getElementById('miluimTypeFilter').value;
    
    // אותה לוגיקת סינון כמו ב-applyFilters
    if (employeeFilter) {
        dataToExport = dataToExport.filter(result => 
            result.employeeId.toString().includes(employeeFilter)
        );
    }
    
    if (yearFilter) {
        dataToExport = dataToExport.filter(result => 
            result.startDate.getFullYear().toString() === yearFilter
        );
    }
    
    if (miluimTypeFilter) {
        dataToExport = dataToExport.filter(result => {
            switch (miluimTypeFilter) {
                case 'regular':
                    return result.startDate < EMERGENCY_START;
                case 'emergency':
                    return result.startDate >= EMERGENCY_START && result.startDate < NEW_MILUIM_START;
                case 'new':
                    return result.isNewMiluim;
                case 'locked':
                    return result.limitedByNewMiluim || result.isValueLocked;
                case 'gap':
                    const calculatedDifference = (result.paidAmount || 0) - (result.continuousValue || 0);
                    return Math.abs(calculatedDifference) > 1;
               case 'crossMonth':
               if (!result.isCrossMonth) return false;
             break;
                     default:                   
                    return true;
            }
        });
    }
    
    if (dataToExport.length === 0) {
        alert('אין נתונים לייצוא.');
        return;
    }
    
// השתמש בנתונים הקיימים עם הכפייה הרציפה שכבר חושבה
const processedData = dataToExport;
    
    const wsData = [
        ['מספר עובד', 'תאריך התחלה', 'תאריך סיום', 'ימי מילואים', 'E - ערך בסיסי', 'F - ערך מומלץ', 'G - ערך רציף', 'I - חירום 90', 'J - מקסימום 120%', 'K - תחילת אשכול', 'סה״כ תשלום', 'סוג חישוב', 'מילואים חדשים', 'אשכול חירום', 'L - ערך בשכר', 'M - פער','N-ערך כפייה','O - כפייה רציפה',
'p-כפייה 4405']
    ];    
   
   for (let result of processedData) {
        wsData.push([
            result.employeeId,
            result.startDate,                       
            result.endDate,                         
            parseInt(result.miluimDays),            
            parseFloat(result.basicValue.toFixed(2)),           
            parseFloat(result.recommendedValue.toFixed(2)),     
            parseFloat(result.continuousValue.toFixed(2)),      
            result.emergencyValue > 0 ? parseFloat(result.emergencyValue.toFixed(2)) : '',
            result.maxEmergencyValue > 0 ? parseFloat(result.maxEmergencyValue.toFixed(2)) : '',
            result.emergencyClusterStart || '',     
            parseFloat((result.continuousValue * result.miluimDays).toFixed(2)), 
            result.calculationType,
            result.isNewMiluim ? 'כן' : 'לא',
            result.isNewCluster ? 'כן' : 'לא',
            parseFloat(result.paidAmount || 0),     
            parseFloat(((result.paidAmount || 0) - result.continuousValue).toFixed(0)), 
            parseFloat(result.compulsion || 0),
            parseFloat(result.compulsionContinuous || 0),
            parseFloat(result.emergencyCompulsion4405 || 0)
        ]);
    }
    
    const wb = XLSX.utils.book_new();
    const ws = XLSX.utils.aoa_to_sheet(wsData);
    
    // הגדרת פורמטים לתאים
    const range = XLSX.utils.decode_range(ws['!ref']);

    for (let R = 1; R <= range.e.r; R++) {
        // תאריכים (עמודות B, C, J)
        ['B', 'C', 'J'].forEach(col => {
            const cellAddress = col + (R + 1);
            if (ws[cellAddress] && ws[cellAddress].v instanceof Date) {
                ws[cellAddress].z = 'dd/mm/yyyy';
                ws[cellAddress].t = 'd';
            }
        });
        
        // מספרים שלמים (עמודה D)
        const dCellAddress = 'D' + (R + 1);
        if (ws[dCellAddress] && typeof ws[dCellAddress].v === 'number') {
            ws[dCellAddress].z = '0';
            ws[dCellAddress].t = 'n';
        }
        
         // סכומי כסף (עמודות E, F, G, H, I, K, O, Q)
        ['E', 'F', 'G', 'H', 'I', 'K', 'O', 'Q'].forEach(col => {
            const cellAddress = col + (R + 1);
            if (ws[cellAddress] && typeof ws[cellAddress].v === 'number') {
                ws[cellAddress].z = '#,##0.00"₪"';
                ws[cellAddress].t = 'n';
            }
        });
    }
    
    // Auto-size columns
    const colWidths = wsData[0].map(() => ({ wch: 15 }));
    ws['!cols'] = colWidths;
    
    XLSX.utils.book_append_sheet(wb, ws, 'תוצאות מילואים');
    
    const fileName = `תוצאות_מילואים_${new Date().toISOString().split('T')[0]}.xlsx`;
    XLSX.writeFile(wb, fileName);
}


        // Event listeners
        document.addEventListener('DOMContentLoaded', function() {
            setupFileUpload();
            
            // הודעת לוג על התיקונים
            console.log('🔥 מחשבון מילואים - גרסה מתוקנת!');
            console.log('✅ תוקן: parseExcelDate (value-1 במקום value-2)');
            console.log('✅ תוקן: ApplyBrutoMinimumFromCSV מוגדר');
            console.log('✅ תוקן: ApplyFinalLimitsFromCSV מוגדר');
            console.log('✅ תוקן: GetBrutoForMonth מחיל ברוטו מינימלי');
            console.log('✅ תוקן: calculateBasicDailyValue משתמש בגבולות סופיים');
            
            document.getElementById('calculateBtn').addEventListener('click', function() {
    const uniqueEmployees = [...new Set(miluimData.map(m => m.employeeId))];
    
    console.log(`מספר עובדים לחישוב: ${uniqueEmployees.length}`);
    
    // אם יש יותר מ-100 עובדים, השתמש בגרסה המקוטעת
    if (uniqueEmployees.length > 100) {
        console.log('משתמש בחישוב מקוטע (Batched)');
        calculateMiluim({
            batchSize: 20,
            showProgress: true,
            enableCancel: true
        });
    } else {
        console.log('îùúîù áçéùåá øâéì');
        calculateMiluim({
            batchSize: 0,
            showProgress: false
        });
    }
});

            // Event listeners לעובד בודד
if (document.getElementById('employeeInput')) {
    document.getElementById('employeeInput').addEventListener('input', validateEmployee);
    document.getElementById('employeeInput').addEventListener('keypress', function(e) {
        if (e.key === 'Enter' && !document.getElementById('calculateSingleBtn').disabled) {
           const selectedEmployee = document.getElementById('employeeInput').value.trim();
    calculateMiluim({
        employeeIds: [selectedEmployee],
        addEmployeeHeader: true,
        batchSize: 0
    });
        }
    });
}
            
            document.getElementById('clearBtn').addEventListener('click', function() {
                miluimData = [];
                salaryData = [];
                attendanceData = [];
                calculationResults = [];
                
                // Reset upload status
                document.querySelector('.upload-card').classList.remove('uploaded');
                updateUploadStatus(false);
                
                // Reset sheet status
                updateSheetStatus('sheet1Status', false, '📊 גליון מילואים: ❌');
                updateSheetStatus('sheet2Status', false, '💰 גליון שכר: ❌');
                updateSheetStatus('sheet3Status', false, '📅 גליון נוכחות: ❌');
                document.getElementById('sheetsStatus').style.display = 'none';
                
                // Clear file input
                document.getElementById('excelFile').value = '';
                
                // Remove messages
                document.querySelectorAll('.success, .error').forEach(msg => msg.remove());
                
                // Reset UI
                document.getElementById('calculateBtn').disabled = true;
                document.getElementById('resultsContainer').innerHTML = '';
                document.getElementById('summaryStats').style.display = 'none';
                document.getElementById('exportSection').style.display = 'none';
            });
            
            document.getElementById('exportBtn').addEventListener('click', exportToExcel);
            
            // Modal close
            document.querySelector('.close').addEventListener('click', function() {
                document.getElementById('detailsModal').style.display = 'none';
            });
            
            window.addEventListener('click', function(event) {
                const modal = document.getElementById('detailsModal');
                if (event.target === modal) {
                    modal.style.display = 'none';
                }
            });
            
            // Filters - עם פונקציה גלובלית
            document.getElementById('employeeFilter').addEventListener('input', applyFilters);
            document.getElementById('yearFilter').addEventListener('change', applyFilters);
            document.getElementById('miluimTypeFilter').addEventListener('change', applyFilters);
            
            // הוספת פונקציה גלובלית
            window.clearFilters = clearFilters;
        });
// משתנה גלובלי
let filterWorker = null;

// יצירת Inline Worker
function createInlineWorker() {
     const workerCode = `
        // 🔥 פונקציה פשוטה לחישוב תאריך מ-Excel
        function simpleExcelToDate(serialNumber) {
            if (typeof serialNumber !== 'number') return null;
            
            const resultDate = new Date(1900, 0, 1);
            resultDate.setDate(resultDate.getDate() + serialNumber - 2);
            return new Date(resultDate.getFullYear(), resultDate.getMonth(), resultDate.getDate());
        }

        self.onmessage = function(e) {
            const { results, filters, miluimData } = e.data;
            self.miluimData = miluimData;
                
            // הסינון
            let filteredResults = results.filter(result => {
                // סינון עובד
                if (filters.employee && !result.employeeId.toString().includes(filters.employee)) {
                    return false;
                }
                
                // סינון שנה
                if (filters.year && result.startDate.getFullYear().toString() !== filters.year) {
                    return false;
                }
                
                // סינון סוג מילואים
                if (filters.miluimType) {
                    switch (filters.miluimType) {
                        case 'new':
                            if (!result.isNewMiluim) return false;
                            break;
                        case 'locked':
                            if (!(result.limitedByNewMiluim || result.isValueLocked)) return false;
                            break;
                        case 'gap':
                            if (Math.abs(result.paidAmount - result.continuousValue) <= 1) return false;
                            break;
                        case 'crossMonth':
                       if (!result.isCrossMonth) return false;
                      break;
                        case 'regular':
                            // צריך להעביר קבועים
                            const EMERGENCY_START = new Date('2023-10-07');
                            if (result.startDate >= EMERGENCY_START) return false;
                            break;
                        case 'emergency':
                            const EMERGENCY_START2 = new Date('2023-10-07');
                            const NEW_MILUIM_START = new Date('2025-05-01');
                            if (!(result.startDate >= EMERGENCY_START2 && result.startDate < NEW_MILUIM_START)) return false;
                            break;
                    }
                }
                
                return true;
            });
            
            self.postMessage(filteredResults);
        };
    `;
    
    const blob = new Blob([workerCode], { type: 'application/javascript' });
    return new Worker(URL.createObjectURL(blob));
}

// אתחול Worker
function initFilterWorker() {
    if (!filterWorker) {
        try {
            filterWorker = createInlineWorker();
            console.log('Inline Web Worker נוצר בהצלחה');
        } catch (error) {
            console.error('שגיאה ביצירת Worker:', error);
            return false;
        }
    }
    return true;
}

function applyFilters() {
    if (calculationResults.length === 0) return;
    
    // נסה ליצור Worker
    if (!initFilterWorker()) {
        console.log('נחזור לסינון רגיל');
        applyFiltersRegular();
        return;
    }
    
    // הכן פילטרים
    const filters = {
        employee: document.getElementById('employeeFilter').value.trim(),
        year: document.getElementById('yearFilter').value,
        miluimType: document.getElementById('miluimTypeFilter').value
    };
    
    // הצג Loading
    document.getElementById('resultsContainer').innerHTML = `
        <div class="loading" style="padding: 40px; text-align: center;">
            🔄 מסנן ${calculationResults.length} תוצאות ברקע...
        </div>
    `;  
      
    // שלח לWorker
      filterWorker.postMessage({
        results: calculationResults,
        filters: filters,
        miluimData: miluimData  // 🔥 הוסף את הנתונים המקוריים
    });
    
    // קבל תוצאות
    filterWorker.onmessage = function(e) {
        const filteredResults = e.data;
        console.log(`סינון הסתיים: ${filteredResults.length} מתוך ${calculationResults.length}`);
        
        // ✅ תיקון: השתמש בפונקציה החדשה במקום הקוד המסוכן הישן
        if (filteredResults.length > 200) {
            // ❌ קוד ישן מסוכן:
            // const originalResults = calculationResults;
            // calculationResults = filteredResults;
            // displayResultsPaginated(1, 50);
            // calculationResults = originalResults;
            
            // ✅ קוד חדש בטוח:
            displayResults(filteredResults, { 
                isFiltered: true, 
                sourceData: calculationResults,
                itemsPerPage: 50,
                page: 1,
                title: '🔍 תוצאות מסוננות (עם עמודים)'
            });
        } else {
            // ❌ קוד ישן:
            // displayFilteredResults(filteredResults);
            
            // ✅ קוד חדש:
            displayResults(filteredResults, { 
                isFiltered: true, 
                sourceData: calculationResults,
                title: '🔍 תוצאות מסוננות'
            });
        }
        
        // ❌ זה לא נדרש יותר - הפונקציה החדשה עושה זאת אוטומטית:
        // updateFilteredStats(filteredResults);
    };
    
    filterWorker.onerror = function(error) {
        console.error('שגיאה ב-Worker:', error);
        applyFiltersRegular();
    };
}

// ✅ גם תקני את applyFiltersRegular (אם יש לך):
function applyFiltersRegular() {
    if (calculationResults.length === 0) return;
    
    // הכן פילטרים
    const filters = {
        employee: document.getElementById('employeeFilter').value.trim(),
        year: document.getElementById('yearFilter').value,
        miluimType: document.getElementById('miluimTypeFilter').value
    };
    
    // סנן את הנתונים
    let filteredResults = [...calculationResults];
    
    // סינון לפי מספר עובד
    if (filters.employee) {
        filteredResults = filteredResults.filter(result => 
            result.employeeId.toString().includes(filters.employee)
        );
    }
    
    // סינון לפי שנה
    if (filters.year) {
        filteredResults = filteredResults.filter(result => 
            result.startDate.getFullYear().toString() === filters.year
        );
    }
    
    // סינון לפי סוג מילואים
    if (filters.miluimType) {
        filteredResults = filteredResults.filter(result => {
            switch (filters.miluimType) {
                case 'regular':
                    const EMERGENCY_START = new Date('2023-10-07');
                    return result.startDate < EMERGENCY_START;
                case 'emergency':
                    const EMERGENCY_START2 = new Date('2023-10-07');
                    const NEW_MILUIM_START = new Date('2025-05-01');
                    return result.startDate >= EMERGENCY_START2 && result.startDate < NEW_MILUIM_START;
                case 'new':
                    return result.isNewMiluim;
                case 'locked':
                    return result.limitedByNewMiluim || result.isValueLocked;
                case 'gap':
                    return Math.abs((result.paidAmount || 0) - result.continuousValue) > 0.01;
                case 'crossMonth':
                    const startDate = new Date(result.startDate);
                    const endDate = new Date(result.endDate);
                    return (startDate.getMonth() !== endDate.getMonth() || 
                            startDate.getFullYear() !== endDate.getFullYear());
                default:
                    return true;
            }
        });
    }
    
    // ✅ השתמש בפונקציה החדשה
    displayResults(filteredResults, { 
        isFiltered: true, 
        sourceData: calculationResults,
        title: filteredResults.length < calculationResults.length ? '🔍 תוצאות מסוננות' : null
    });
}
      
        function updateFilteredStats(filteredResults) {
            const uniqueEmployees = new Set(filteredResults.map(r => r.employeeId)).size;
            const totalPeriods = filteredResults.length;
            const totalDays = filteredResults.reduce((sum, r) => sum + r.miluimDays, 0);
            const totalPayment = filteredResults.reduce((sum, r) => sum + (r.continuousValue * r.miluimDays), 0);
            
            document.getElementById('totalEmployees').textContent = uniqueEmployees;
            document.getElementById('totalPeriods').textContent = totalPeriods;
            document.getElementById('totalDays').textContent = totalDays;
            document.getElementById('totalPayment').textContent = formatCurrency(totalPayment);
        }

        function clearFilters() {
            document.getElementById('employeeFilter').value = '';
            document.getElementById('yearFilter').value = '';
            document.getElementById('miluimTypeFilter').value = '';
            displayResults(calculationResults, { 
            itemsPerPage: calculationResults.length > 500 ? 100 : null });
            updateSummaryStats();
        }
// ========================
// שלב ב' - אנליזה מתקדמת
// ========================
function analyzeGaps_basic() {
    console.log("🔍 מתחיל ניתוח פערים...");
    
    if (!calculationResults || calculationResults.length === 0) {
        alert("❌ לא נמצאו תוצאות חישוב. הרץ תחילה 'חשב מילואים'");
        return;
    }
    
    const analysis = categorizeGaps();
    showAnalysisWindow(analysis);
}

function categorizeGaps() {
    // בדיקת Debug
    console.log("🔍 התחלת בדיקת פערים...");
    console.log("מספר תוצאות:", calculationResults.length);

    const categories = {
        monthlyRule: { name: "ערך בגין חודשי (לפני 1.5.2025)", status: "ok", items: [], icon: "✅" },
        continuousValue: { name: "ערך כפוי מרצף", status: "ok", items: [], icon: "✅" },
        higherValue60DayIssue: { name: "תקלת חוקה - יש לתת ערך בגין מ-60 יום (מילואים רגילים)", status: "fix", items: [], icon: "🚫" },
        newMiluimHigherValueIssue: { name: "תקלת חוקה - אין לתת ערך בגין מ-60 יום (מילואים חדשים)", status: "fix", items: [], icon: "⚠️" },
        forceValueNotApplied: { name: "אי החלת ערך כפייה", status: "fix", items: [], icon: "🚨" },
        emergencyCompulsionNotApplied: { name: "תקלת חוקה - לא הוחל כפיית ערך חירום", status: "fix", items: [], icon: "⚡" },
        minimumValueIssue: { name: "שולם ערך קטן משכר מינימום", status: "fix", items: [], icon: "💰" },
        incorrectMinimumBruto: { name: "תקלה בחוקה - ברוטו מינימלי לא תקין", status: "fix", items: [], icon: "📊" },
        unknown: { name: "לא מזוהה", status: "check", items: [], icon: "🤔" }
    };
    
    let totalRecords = calculationResults.length;
    let gapsFound = 0;
    let noGaps = 0;
    const analysisStartDate = new Date('2023-01-01');
    
    calculationResults.forEach(result => {
        if (result.startDate < analysisStartDate) {
            return;
        }
        
        const columnG = result.continuousValue || 0;
        const columnL = result.paidAmount || 0;
        const columnO = result.compulsionContinuous || 0;
        const columnP = result.emergencyCompulsion4405 || 0;
        let categoryFound = false;
        
        // **שלב 1: בדיקת ערכי כפייה - זה חייב להתאמה לערך משולם!**
        
        // בדיקה 1.1: ערך כפוי מרצף (עמודה O)
        if (columnO > 0 && Math.abs(columnL - columnO) > 1) {
            categories.forceValueNotApplied.items.push({
                employeeId: result.employeeId,
                period: `${formatDate(result.startDate)} - ${formatDate(result.endDate)}`,
                gap: (columnL - columnO).toFixed(2),
                columnG: columnG.toFixed(2),
                columnL: columnL.toFixed(2),
                columnO: columnO.toFixed(2),
                explanation: "יש ערך כפוי מרצף - לא הותאם לתשלום",
                details: `שולם ${columnL}₪ במקום ${columnO}₪ - פער של ${(columnL - columnO).toFixed(2)}₪`
            });
            categoryFound = true;
            gapsFound++;
        }
        
        // בדיקה 1.2: ערך כפיית חירום (עמודה P) - מילואים חדשים
       if (result.isNewMiluim && columnP > 0 && Math.abs(columnL - columnP) > 1) {
            categories.emergencyCompulsionNotApplied.items.push({
                employeeId: result.employeeId,
                period: `${formatDate(result.startDate)} - ${formatDate(result.endDate)}`,
                gap: (columnL - columnP).toFixed(2),
                columnG: columnG.toFixed(2),
                columnL: columnL.toFixed(2),
                columnP: columnP.toFixed(2),
                explanation: "מילואים חדשים - שולם יותר מערך הכפייה החירום",
                details: `שולם ${columnL}₪ במקום ${columnP}₪ - יתרת תשלום ${(columnL - columnP).toFixed(2)}₪`
            });
            categoryFound = true;
            gapsFound++;
        }
        
        // **שלב 2: בדיקות כשאין ערכי כפייה (O=0 ו-P=0)**
        else if (columnO === 0 && columnP === 0 && Math.abs(columnG - columnL) > 1) {
            
            // בדיקה 2.1: ערך קטן משכר מינימום
            if (checkMinimumValue(columnL, result.startDate)) {
                const minimumDaily = getMinimumDailyForDate(result.startDate);
                categories.minimumValueIssue.items.push({
                    employeeId: result.employeeId,
                    period: `${formatDate(result.startDate)} - ${formatDate(result.endDate)}`,
                    gap: (minimumDaily - columnL).toFixed(2),
                    columnG: columnG.toFixed(2),
                    columnL: columnL.toFixed(2),
                    explanation: "שולם ערך קטן משכר מינימום",
                    details: `שולם ${columnL}₪ - פחות מהמינימום ${minimumDaily}₪ לתאריך השירות`
                });
                categoryFound = true;
                gapsFound++;
            }
            
            // בדיקה 2.2: בדיקת ברוטו מינימלי לא תקין
            else {
                const alternativeValue = calculateBasicFromMinimumDaily(result.employeeId, result.startDate);
                if (Math.abs(columnL - alternativeValue) <= 1 && Math.abs(columnG - columnL) <= 1) {
                    categories.incorrectMinimumBruto.items.push({
                        employeeId: result.employeeId,
                        period: `${formatDate(result.startDate)} - ${formatDate(result.endDate)}`,
                        gap: (columnG - columnL).toFixed(2),
                        columnG: columnG.toFixed(2),
                        columnL: columnL.toFixed(2),
                        explanation: "תקלה בחוקה - ברוטו מינימלי לא תקין",
                        details: `חושב לפי ברוטו מינימלי ${alternativeValue.toFixed(2)}₪ במקום ערך נכון ${columnG.toFixed(2)}₪`
                    });
                    categoryFound = true;
                    gapsFound++;
                }
                
                // בדיקה 2.3: פונקציית אבחון מתקדמת - מילואים רגילים שלא קיבלו ערך גבוה מ-60 יום
                else {
                    const diagnosis = diagnoseGapWithNewMethods(result);
                    if (diagnosis && diagnosis.issue === "60DayHigherValueNotGiven") {
                        categories.higherValue60DayIssue.items.push({
                            employeeId: result.employeeId,
                            period: `${formatDate(result.startDate)} - ${formatDate(result.endDate)}`,
                            gap: (diagnosis.columnF - diagnosis.columnL).toFixed(2),
                            columnG: diagnosis.columnG.toFixed(2),
                            columnL: diagnosis.columnL.toFixed(2),
                            explanation: diagnosis.explanation,
                            details: `חישוב בסיסי (E): ${diagnosis.columnE.toFixed(2)}₪ | ערך מ-60 יום (F): ${diagnosis.columnF.toFixed(2)}₪ | שולם: ${diagnosis.columnL.toFixed(2)}₪`
                        });
                        categoryFound = true;
                        gapsFound++;
                    }
                    
                    // בדיקה 2.4: פונקציית אבחון מתקדמת - מילואים חדשים שקיבלו ערך גבוה
                    else {
                        const newMiluimDiagnosis = diagnoseNewMiluimHigherValue(result);
                        if (newMiluimDiagnosis && newMiluimDiagnosis.issue === "NewMiluimHigherValueGiven") {
                            categories.newMiluimHigherValueIssue.items.push({
                                employeeId: result.employeeId,
                                period: `${formatDate(result.startDate)} - ${formatDate(result.endDate)}`,
                                gap: (newMiluimDiagnosis.columnL - newMiluimDiagnosis.columnE).toFixed(2),
                                columnG: columnG.toFixed(2),
                                columnL: newMiluimDiagnosis.columnL.toFixed(2),
                                columnE: newMiluimDiagnosis.columnE.toFixed(2),
                                explanation: newMiluimDiagnosis.explanation,
                                details: `היה צריך לקבל ערך בסיסי ${newMiluimDiagnosis.columnE.toFixed(2)}₪ אבל קיבל ${newMiluimDiagnosis.columnL.toFixed(2)}₪`
                            });
                            categoryFound = true;
                            gapsFound++;
                        }
                        
                        // בדיקה 2.5: בדיקות נוספות (מהקוד המקורי)
                        else {
                            const gap = Math.abs(columnG - columnL);
                            
                            // בדיקת כלל חודשי מתקדם
                            const monthlyCheck = checkMonthlyRuleAdvanced(result, calculationResults);
                            if (monthlyCheck) {
                                categories.monthlyRule.items.push({
                                    employeeId: result.employeeId,
                                    period: `${formatDate(result.startDate)} - ${formatDate(result.endDate)}`,
                                    gap: gap.toFixed(2),
                                    columnG: columnG.toFixed(2),
                                    columnL: columnL.toFixed(2),
                                    explanation: monthlyCheck.explanation,
                                    details: `${monthlyCheck.monthPeriods} תקופות באותו חודש, ערכים: ${monthlyCheck.allValues.map(v => v.toFixed(2)).join(', ')}₪`
                                });
                                categoryFound = true;
                                gapsFound++;
                            }
                            
                            // בדיקת ערך כפוי מרצף - התאמה
                            else {
                                const compulsionValue = result.compulsionContinuous || 0;
                                const compulsionOriginal = result.compulsion || 0;
                                
                                const matchesN = compulsionOriginal > 0 && Math.abs(columnL - compulsionOriginal) <= 1;
                                const matchesO = compulsionValue > 0 && Math.abs(columnL - compulsionValue) <= 1;
                                
                                if (matchesN || matchesO) {
                                    categories.continuousValue.items.push({
                                        employeeId: result.employeeId,
                                        period: `${formatDate(result.startDate)} - ${formatDate(result.endDate)}`,
                                        gap: gap.toFixed(2),
                                        columnG: columnG.toFixed(2),
                                        columnL: columnL.toFixed(2),
                                        columnN: result.compulsion || 0,
                                        columnO: result.compulsionContinuous || 0,
                                        explanation: "תקופה עם ערך כפוי תקין",
                                        details: matchesN ? 
                                            `תואם עמודה N: ${compulsionOriginal}₪` : 
                                            `תואם עמודה O: ${compulsionValue}₪`
                                    });
                                    categoryFound = true;
                                    gapsFound++;
                                }
                                
                              
                                // לא מזוהה
                                else {
                                    categories.unknown.items.push({
                                        employeeId: result.employeeId,
                                        period: `${formatDate(result.startDate)} - ${formatDate(result.endDate)}`,
                                        gap: gap.toFixed(2),
                                        columnG: columnG.toFixed(2),
                                        columnL: columnL.toFixed(2),
                                        explanation: "סיבת הפער לא ברורה",
                                        details: "דורש בדיקה ידנית"
                                    });
                                    categoryFound = true;
                                    gapsFound++;
                                }
                            }
                        }
                    }
                }
            }
        }
        
        // אם לא נמצא פער או הפער קטן מ-1 ש"ח
        if (!categoryFound) {
            noGaps++;
        }
    });
    
    return {
        totalRecords,
        gapsFound,
        noGaps,
        categories
    };
}
   
function diagnoseGapWithNewMethods(result) {
    const columnG = result.continuousValue || 0;
    const columnL = result.paidAmount || 0;
    const gap = Math.abs(columnG - columnL);
    const tolerance = 1.0;
    
    if (gap <= tolerance) {
        return null;
    }
    
    const employeeId = result.employeeId;
    const serviceStartDate = result.startDate;
    
    // תיקון - שימוש נכון בפונקציות
    const basicResult = calculateBasicDailyValue(employeeId, serviceStartDate);
    const columnE = basicResult.dailyValue; // לקחת את dailyValue מהאובייקט
    
    const columnF = calculateRecommendedValue(employeeId, serviceStartDate, columnE); // העברת basicValue
    
    console.log(`Debug for employee ${employeeId}:`);
    console.log(`columnE (basic): ${columnE}`);
    console.log(`columnF (recommended): ${columnF}`);
    console.log(`columnG (continuous): ${columnG}`);
    console.log(`columnL (paid): ${columnL}`);
  
    // התנאים לזיהוי "תקלת חוקה - יש לתת ערך גבוה מ-60 יום":
const condition1 = Math.abs(columnL - columnE) <= tolerance; // L = E (שולם לפי בסיסי)
const condition2 = columnF > columnE; // F גבוה מ-E (יש ערך גבוה יותר מ-60 יום)
const condition3 = Math.abs(columnG - columnF) <= tolerance; // G = F (המערכת חישבה נכון)
const condition4 = !result.isNewMiluim; // 🆕 לא מילואים חדשים!

if (condition1 && condition2 && condition3 && condition4) {
    return {
        issue: "60DayHigherValueNotGiven",
        explanation: "תקלת חוקה - יש לתת ערך גבוה מ-60 יום אחרונים",
        columnE: columnE,
        columnF: columnF,
        columnG: columnG,
        columnL: columnL,
        shouldHavePaid: columnF
    };
}
    
    // אם לא - המשך לבדיקות אחרות...
    return null;
}
function diagnoseNewMiluimHigherValue(result) {
    if (!result.isNewMiluim) return null;
    
    const columnG = result.continuousValue || 0;
    const columnL = result.paidAmount || 0;
    const tolerance = 1.0;
    
    // חישוב ערך בסיסי
    const basicResult = calculateBasicDailyValue(result.employeeId, result.startDate);
    const columnE = basicResult.dailyValue;
    
    // בדיקה: האם שולם יותר מהערך הבסיסי?
    if (Math.abs(columnL - columnE) <= tolerance) {
        return null; // שולם ערך בסיסי - תקין
    }
    
    if (columnL > columnE + tolerance) {
        return {
            issue: "NewMiluimHigherValueGiven",
            explanation: "מילואים חדשים - שולם ערך גבוה במקום בסיסי",
            columnE: columnE,
            columnL: columnL,
            shouldHavePaid: columnE
        };
    }
    
    return null;
}
// ========================
// פונקציית בדיקה מתקדמת - כלל חודשי
// ========================
function checkMonthlyRuleAdvanced(result, allResults) {
    // תנאי 1: לפני 1.5.2025
    if (result.startDate >= new Date('2025-05-01')) {
        return null; // לא רלוונטי
    }
    
    // מציאת חודש+שנה של התקופה הנוכחית
    const currentMonth = result.startDate.getMonth();
    const currentYear = result.startDate.getFullYear();
    
    // מציאת כל התקופות באותו חודש (של אותו עובד)
    const sameMonthPeriods = allResults.filter(r => 
        r.employeeId === result.employeeId &&
        r.startDate.getMonth() === currentMonth &&
        r.startDate.getFullYear() === currentYear
    );
    
    // תנאי 2: יש יותר מתקופה אחת באותו חודש
    if (sameMonthPeriods.length <= 1) {
        return null; // אין מספר תקופות
    }
    
    // תנאי 3: יש ערכים שונים בעמודה G
    const columnGValues = sameMonthPeriods.map(r => r.continuousValue || 0);
    const uniqueValues = [...new Set(columnGValues)];
    if (uniqueValues.length <= 1) {
        return null; // כל הערכים זהים
    }
    
    // תנאי 4: הערך בעמודה L = הערך הגבוה ביותר בעמודה G
    const maxColumnG = Math.max(...columnGValues);
    const currentColumnL = result.paidAmount || 0;
    
    // בדיקה אם הערך בשכר תואם לערך הגבוה (סטייה עד 1 ש"ח)
    if (Math.abs(currentColumnL - maxColumnG) <= 1) {
        return {
            matched: true,
            explanation: `החוקה החילה ערך גבוה (${maxColumnG.toFixed(2)}₪) מ-${sameMonthPeriods.length} תקופות באותו חודש`,
            monthPeriods: sameMonthPeriods.length,
            maxValue: maxColumnG,
            allValues: uniqueValues
        };
    }
    
    return null; // לא תואם לכלל
}

// חישוב לפי שלושה חודשים אחרונים מותאם לברוטו מינמלי
function calculateAlwaysLast3WithMinimum(employeeId, serviceStartDate) {
    const serviceMonth = new Date(serviceStartDate.getFullYear(), serviceStartDate.getMonth(), 1);
    
    const month1 = new Date(serviceMonth.getFullYear(), serviceMonth.getMonth() - 1, 1);
    const month2 = new Date(serviceMonth.getFullYear(), serviceMonth.getMonth() - 2, 1);
    const month3 = new Date(serviceMonth.getFullYear(), serviceMonth.getMonth() - 3, 1);
    
    let totalBruto = 0;
    totalBruto += GetBrutoForMonth(employeeId, month1);
    totalBruto += GetBrutoForMonth(employeeId, month2);
    totalBruto += GetBrutoForMonth(employeeId, month3);
    
    return totalBruto / 90;
}

function calculateBest3From6WithMinimum(employeeId, serviceStartDate) {
    const serviceMonth = new Date(serviceStartDate.getFullYear(), serviceStartDate.getMonth(), 1);
    
    // בניית רשימת 6 החודשים האחרונים
    const months = [];
    for (let i = 1; i <= 6; i++) {
        const month = new Date(serviceMonth.getFullYear(), serviceMonth.getMonth() - i, 1);
        months.push({
            date: month,
            bruto: GetBrutoForMonth(employeeId, month) // עם מינימום ברוטו
        });
    }
    
    // מיון לפי ברוטו מהגבוה לנמוך ולקיחת 3 הטובים
    const bestMonths = months
        .sort((a, b) => b.bruto - a.bruto)
        .slice(0, 3);
    
    // חישוב סכום ברוטו של 3 החודשים הטובים
    const totalBruto = bestMonths.reduce((sum, month) => sum + month.bruto, 0);
    
    // חזרת ערך יומי
    return totalBruto / 90;
}
// פונקציות עזר חדשות - מחוץ לפונקציה הראשית
function checkMinimumValue(columnL, serviceStartDate) {
    // מציאת הערך המינימלי לפי תאריך השירות
    for (let limit of DAILY_LIMITS) {
        if (serviceStartDate >= limit.start && serviceStartDate <= limit.end) {
            return columnL < limit.min;
        }
    }
    // Default to latest limits if no match found
    const latestLimit = DAILY_LIMITS[DAILY_LIMITS.length - 1];
    return columnL < latestLimit.min;
}

function getMinimumDailyForDate(serviceStartDate) {
    // מציאת הערך המינימלי לפי תאריך השירות
    for (let limit of DAILY_LIMITS) {
        if (serviceStartDate >= limit.start && serviceStartDate <= limit.end) {
            return limit.min;
        }
    }
    // Default to latest limits if no match found
    const latestLimit = DAILY_LIMITS[DAILY_LIMITS.length - 1];
    return latestLimit.min;
}

function calculateBasicFromMinimumDaily(employeeId, serviceStartDate) {
    // פונקציה שמחקה את תקלת החוקה: שימוש בברוטו מינימלי מחושב (יום מינימום * 30)
    // במקום הברוטו מינימלי הקבוע מהטבלה
    
    const minimumDaily = getMinimumDailyForDate(serviceStartDate);
    const calculatedMinimumMonthly = minimumDaily * 30; // התקלה - חישוב במקום קבוע!
    
    // חישוב זהה לפונקציה המקורית
    const serviceMonth = new Date(serviceStartDate.getFullYear(), serviceStartDate.getMonth(), 1);
    
    const month1 = new Date(serviceMonth.getFullYear(), serviceMonth.getMonth() - 1, 1);
    const month2 = new Date(serviceMonth.getFullYear(), serviceMonth.getMonth() - 2, 1);
    const month3 = new Date(serviceMonth.getFullYear(), serviceMonth.getMonth() - 3, 1);
    
    // בדיקת ימי עבודה ב-3 חודשים (כמו בפונקציה המקורית)
    const workDays1 = GetWorkDaysForMonth(employeeId, month1, serviceStartDate);
    const workDays2 = GetWorkDaysForMonth(employeeId, month2, serviceStartDate);
    const workDays3 = GetWorkDaysForMonth(employeeId, month3, serviceStartDate);
    const totalWorkDays = workDays1 + workDays2 + workDays3;
    
    let totalBruto = 0;
    
    if (totalWorkDays >= 60) {
        // חישוב רגיל - 3 חודשים, אבל עם ברוטו מחושב (התקלה)
        // במקום GetBrutoForMonth (שמחיל קבועים נכונים), נשתמש בברוטו המחושב השגוי
        const bruto1 = Math.max(getBestBrutoForMonth(employeeId, month1), calculatedMinimumMonthly);
        const bruto2 = Math.max(getBestBrutoForMonth(employeeId, month2), calculatedMinimumMonthly);
        const bruto3 = Math.max(getBestBrutoForMonth(employeeId, month3), calculatedMinimumMonthly);
        totalBruto = bruto1 + bruto2 + bruto3;
    } else {
        // חישוב חלופי - 3 החודשים הטובים מ-6, אבל עם ברוטו מחושב
        const months = [];
        for (let i = 1; i <= 6; i++) {
            const month = new Date(serviceMonth.getFullYear(), serviceMonth.getMonth() - i, 1);
            const brutoBest = getBestBrutoForMonth(employeeId, month);
            const brutoWithCalculatedMin = Math.max(brutoBest, calculatedMinimumMonthly);
            months.push({ date: month, bruto: brutoWithCalculatedMin });
        }
        
        // מיון לפי ברוטו יורד ולקיחת 3 הטובים
        months.sort((a, b) => b.bruto - a.bruto);
        totalBruto = months.slice(0, 3).reduce((sum, month) => sum + month.bruto, 0);
    }
    
    const dailyValue = totalBruto / 90;
    let finalValue = ApplyFinalLimitsFromCSV(dailyValue, serviceStartDate);
    
    return finalValue;
}

// פונקציה עזר - מחזירה ברוטו גולמי בלי החלת מינימום (לפני התקלה)
function getBestBrutoForMonth(employeeId, monthDate) {
    const monthStart = new Date(monthDate.getFullYear(), monthDate.getMonth(), 1);
    const monthEnd = new Date(monthDate.getFullYear(), monthDate.getMonth() + 1, 0);
    
    let bestBruto = 0;
    
    for (let salary of salaryData) {
        if (salary.employeeId == employeeId) {
            const salaryDate = parseExcelDate(salary.monthYear);
            if (salaryDate && salaryDate >= monthStart && salaryDate <= monthEnd) {
                bestBruto = Math.max(bestBruto, salary.bruto || 0);
            }
        }
    }
    
    return bestBruto; // ללא החלת מינימום - זה מה שהיה לפני התקלה
}
// 🆕 פונקציה לייצוא ניתוח פערים לאקסל
function exportGapsToExcel() {
    console.log("🔄 מתחיל ייצוא ניתוח פערים לאקסל...");
    
    // חישוב הנתונים מחדש
    const analysis = categorizeGaps();
    
    // יצירת workbook חדש
    const wb = XLSX.utils.book_new();
    
    // 1. יצירת גליון סיכום
    createSummarySheet(wb, analysis);
    
    // 2. יצירת גליון לכל קטגוריה עם פריטים
    Object.entries(analysis.categories).forEach(([categoryKey, category]) => {
        if (category.items.length > 0) {
            createCategorySheet(wb, categoryKey, category);
        }
    });
    
    // 3. יצירת גליון כל הפערים
    createAllGapsSheet(wb, analysis);
    
    // יצירת שם קובץ עם תאריך ושעה
    const now = new Date();
    const timestamp = now.toISOString().slice(0, 16).replace(/[:-]/g, '').replace('T', '_');
    const filename = `ניתוח_פערים_${timestamp}.xlsx`;
    
    // הורדת הקובץ
    XLSX.writeFile(wb, filename);
    
    console.log(`✅ ייצוא הושלם: ${filename}`);
    alert(`✅ הקובץ נוצר בהצלחה!\n📁 ${filename}`);
}

// פונקציה ליצירת גליון סיכום
function createSummarySheet(wb, analysis) {
    const summaryData = [
        ['ניתוח פערים - סיכום מנהלים', '', '', ''],
        ['תאריך יצירה:', new Date().toLocaleDateString('he-IL'), '', ''],
        ['', '', '', ''],
        ['📊 סטטיסטיקות כלליות', '', '', ''],
        ['סה"כ רשומות:', analysis.totalRecords, '', ''],
        ['ללא פערים:', analysis.noGaps, `${(analysis.noGaps/analysis.totalRecords*100).toFixed(1)}%`, ''],
        ['פערים זוהו:', analysis.gapsFound, `${(analysis.gapsFound/analysis.totalRecords*100).toFixed(1)}%`, ''],
        ['', '', '', ''],
        ['📋 פירוט לפי קטגוריות', '', '', ''],
        ['קטגוריה', 'מספר מקרים', 'אחוז', 'סטטוס']
    ];
    
    // הוספת נתוני קטגוריות
    Object.entries(analysis.categories).forEach(([key, category]) => {
        if (category.items.length > 0) {
            const percentage = ((category.items.length / analysis.totalRecords) * 100).toFixed(1);
            const statusText = category.status === 'ok' ? 'תקין' : 
                              category.status === 'fix' ? 'דורש תיקון' : 'בדיקה';
            summaryData.push([
                category.name,
                category.items.length,
                `${percentage}%`,
                statusText
            ]);
        }
    });
    
    const ws = XLSX.utils.aoa_to_sheet(summaryData);
    
    // עיצוב הגליון
    ws['!cols'] = [
        { wch: 30 }, // עמודה A
        { wch: 15 }, // עמודה B  
        { wch: 15 }, // עמודה C
        { wch: 15 }  // עמודה D
    ];
    
    XLSX.utils.book_append_sheet(wb, ws, 'סיכום');
}

// פונקציה ליצירת גליון לקטגוריה ספציפית
function createCategorySheet(wb, categoryKey, category) {
    const data = [
        [`${category.icon} ${category.name}`, '', '', '', '', ''],
        ['עובד', 'תקופה', 'פער (ש"ח)', 'עמודה G', 'עמודה L', 'הסבר'],
        []
    ];
    
    // הוספת נתוני הפריטים
    category.items.forEach(item => {
        data.push([
            item.employeeId,
            item.period,
            item.gap,
            item.columnG,
            item.columnL,
            item.explanation + (item.details ? ` | ${item.details}` : '')
        ]);
    });
    
    // הוספת סיכום בתחתית
    const totalGap = category.items.reduce((sum, item) => sum + parseFloat(item.gap), 0);
    data.push([]);
    data.push(['סיכום:', '', totalGap.toFixed(2), '', '', `${category.items.length} מקרים`]);
    
    const ws = XLSX.utils.aoa_to_sheet(data);
    
    // עיצוב עמודות
    ws['!cols'] = [
        { wch: 12 }, // עובד
        { wch: 25 }, // תקופה
        { wch: 12 }, // פער
        { wch: 12 }, // עמודה G
        { wch: 12 }, // עמודה L
        { wch: 40 }  // הסבר
    ];
    
    // שם הגליון (מקוצר למקסימום 31 תווים)
    let sheetName = category.name.substring(0, 31);
    if (sheetName.endsWith('...')) {
        sheetName = sheetName.substring(0, 28) + '...';
    }
    
    XLSX.utils.book_append_sheet(wb, ws, sheetName);
}

// פונקציה ליצירת גליון עם כל הפערים
function createAllGapsSheet(wb, analysis) {
    const data = [
        ['כל הפערים המזוהים', '', '', '', '', '', ''],
        ['עובד', 'תקופה', 'פער (ש"ח)', 'עמודה G', 'עמודה L', 'קטגוריה', 'הסבר'],
        []
    ];
    
    // איסוף כל הפריטים מכל הקטגוריות
    Object.entries(analysis.categories).forEach(([key, category]) => {
        category.items.forEach(item => {
            data.push([
                item.employeeId,
                item.period,
                item.gap,
                item.columnG,
                item.columnL,
                category.name,
                item.explanation + (item.details ? ` | ${item.details}` : '')
            ]);
        });
    });
    
    // הוספת סיכום כללי
    const totalItems = Object.values(analysis.categories).reduce((sum, cat) => sum + cat.items.length, 0);
    const totalGapAmount = Object.values(analysis.categories)
        .flatMap(cat => cat.items)
        .reduce((sum, item) => sum + parseFloat(item.gap), 0);
    
    data.push([]);
    data.push(['סה"כ:', '', totalGapAmount.toFixed(2), '', '', `${totalItems} מקרים`, '']);
    
    const ws = XLSX.utils.aoa_to_sheet(data);
    
    // עיצוב עמודות
    ws['!cols'] = [
        { wch: 12 }, // עובד
        { wch: 25 }, // תקופה  
        { wch: 12 }, // פער
        { wch: 12 }, // עמודה G
        { wch: 12 }, // עמודה L
        { wch: 20 }, // קטגוריה
        { wch: 50 }  // הסבר
    ];
    
    XLSX.utils.book_append_sheet(wb, ws, 'כל הפערים');
}
function showAnalysisWindow(analysis) {
    // הצגת סיכום
    document.getElementById('analysisSummary').innerHTML = `
        <div class="summary-stat">
            <h4>סה"כ רשומות</h4>
            <div style="font-size: 1.5em; color: #2196f3;">${analysis.totalRecords}</div>
        </div>
        <div class="summary-stat">
            <h4>ללא פערים</h4>
            <div style="font-size: 1.5em; color: #4caf50;">${analysis.noGaps}</div>
            <small>(${(analysis.noGaps/analysis.totalRecords*100).toFixed(1)}%)</small>
        </div>
        <div class="summary-stat">
            <h4>פערים זוהו</h4>
            <div style="font-size: 1.5em; color: #ff9800;">${analysis.gapsFound}</div>
            <small>(${(analysis.gapsFound/analysis.totalRecords*100).toFixed(1)}%)</small>
        </div>
        <h2>🔍 ניתוח פערים מפורט</h2>
        <div style="display: flex; gap: 10px;">
            <button class="btn" onclick="exportGapsToExcel()" style="background: #2e7d32; color: white;">
                📊 ייצא לאקסל
            </button>
            <button class="btn" onclick="closeAnalysisWindow()" style="background: #d32f2f; color: white;">
                ❌ סגור
            </button>
        </div>
    `;
    
    // הצגת קטגוריות
    let categoriesHTML = '';
    Object.entries(analysis.categories).forEach(([key, category]) => {
        if (category.items.length > 0) {
            const statusIcon = category.status === 'ok' ? '✅' : category.status === 'fix' ? '❌' : '🤔';
            const statusText = category.status === 'ok' ? 'תקין' : category.status === 'fix' ? 'דורש תיקון' : 'בדיקה ידנית';
            
            categoriesHTML += `
                <div class="category-box category-${category.status}">
                    <div class="category-header" onclick="toggleCategory('${key}')">
                        <span>${statusIcon} ${category.name}</span>
                        <span>${category.items.length} מקרים | ${statusText}</span>
                    </div>
                    <div class="category-content" id="category-${key}">
                        <table style="width: 100%; border-collapse: collapse;">
                            <thead>
                                <tr style="background: #f0f0f0;">
                                    <th style="padding: 8px; border: 1px solid #ddd;">עובד</th>
                                    <th style="padding: 8px; border: 1px solid #ddd;">תקופה</th>
                                    <th style="padding: 8px; border: 1px solid #ddd;">עמודה G</th>
                                    <th style="padding: 8px; border: 1px solid #ddd;">עמודה L</th>
                                    <th style="padding: 8px; border: 1px solid #ddd;">פער</th>
                                    <th style="padding: 8px; border: 1px solid #ddd;">הסבר</th>
                                    <th style="padding: 8px; border: 1px solid #ddd;">פרטים נוספים</th>
                                </tr>
                            </thead>
                            <tbody>
                                ${category.items.map(item => `
                                    <tr>
                                        <td style="padding: 8px; border: 1px solid #ddd;"><strong>${item.employeeId}</strong></td>
                                        <td style="padding: 8px; border: 1px solid #ddd;">${item.period}</td>
                                        <td style="padding: 8px; border: 1px solid #ddd;">${item.columnG} ₪</td>
                                        <td style="padding: 8px; border: 1px solid #ddd; background: #e8f5e8;"><strong>${item.columnL} ₪</strong></td>
                                        <td style="padding: 8px; border: 1px solid #ddd; font-weight: bold; color: #ff9800;">${item.gap} ₪</td>
                                        <td style="padding: 8px; border: 1px solid #ddd; font-size: 0.9em;">${item.explanation}</td>
                                        <td style="padding: 8px; border: 1px solid #ddd; font-size: 0.8em; color: #666;">${item.details || ''}</td>
                                    </tr>
                                `).join('')}
                            </tbody>
                        </table>
                    </div>
                </div>
            `;
        }
    });
    
    document.getElementById('analysisCategories').innerHTML = categoriesHTML;
    
    // הצגת החלון
    document.getElementById('analysisOverlay').style.display = 'block';
    document.getElementById('analysisWindow').style.display = 'block';
}

function toggleCategory(categoryId) {
    const content = document.getElementById('category-' + categoryId);
    content.style.display = content.style.display === 'block' ? 'none' : 'block';
}

function closeAnalysis() {
    document.getElementById('analysisOverlay').style.display = 'none';
    document.getElementById('analysisWindow').style.display = 'none';
}
    </script>
<!-- חלון אנליזה נפרד -->
<div class="overlay" id="analysisOverlay" onclick="closeAnalysis()"></div>
<div class="analysis-window" id="analysisWindow">
    <div class="analysis-header">
        <h2>🔍 ניתוח פערים במילואים</h2>
        <button class="close-btn" onclick="closeAnalysis()">×</button>
    </div>
    
    <div class="analysis-content">
        <div class="analysis-summary" id="analysisSummary">
            <!-- סיכום כללי -->
        </div>
        
        <div class="analysis-categories" id="analysisCategories">
            <!-- קטגוריות פערים -->
        </div>
    </div>
</div>
</body>
</html>
